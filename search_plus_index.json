{"./":{"url":"./","title":"Poppy","keywords":"","body":"Welcome to Poppy's blog!        Welcome to Poppy's blog! "},"SUMMARY.html":{"url":"SUMMARY.html","title":"SUMMARY","keywords":"","body":"Summary Poppy SUMMARY Django Flask MySQL MySQL之概述 MySQL之基本操作 MySQL之视图 MySQL之索引 Basic Data Type File Operations Function Function Advanced Recursion Decorator Object-Oriented Object-Oriented Advanced README Socket Socket Introduce Web HTML CSS JavaScript BOM And DOM "},"Django/":{"url":"Django/","title":"Django","keywords":"","body":"Introduction "},"Flask/":{"url":"Flask/","title":"Flask","keywords":"","body":"Introduction Flask是一款非常流行的Python Web框架，出生于2010年，本是作者Armin Ronacher的一个愚人节玩笑，不过后来大受欢迎，进而成为一个正式项目。目前最新版本是1.0.2。 Flask自2010年发布第一个版本以来，深得开发者的喜爱，并在多个公司得到应用，而flask能如此流行的原因，可以分为以下几点： 轻量，微框架 简洁，只提供核心功能， 给开发者提供了很大的扩展性 开发效率高 与Django不同的是，Flask依赖两个外部库：Jinja2模板引擎和Werkzeug WSGI。Flask的灵活度非常高，不会帮你做太多决策，即使已经帮你做出选择，也可以非常容易的更换成你需要的，例如： 使用Flask开发数据库时，具体是使用SQLAlchemy还是MongoEngine或者是不用ORM而直接基于MySQL-Python这样的底层驱动进行开发都可以，选择权完全掌握在你自己手中。区别于Django，Django内置了非常完善和丰富的功能，若你想替换成自己想要的，要么不支持，要么非常麻烦 "},"MySQL/":{"url":"MySQL/","title":"MySQL","keywords":"","body":"简介 MySQL原本是一个开放源代码的关系数据库管理系统（DBMS），原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。在本教程中，会让大家快速掌握MySQL的基本知识，并轻松使用MySQL数据库 MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用在Internet上的中小型网站中。是最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。随着MySQL的不断成熟，它也逐渐用于更多大规模网站和应用，比如维基百科、Google和Facebook等网站 但被甲骨文公司收购后，Oracle大幅调涨MySQL商业版的售价，且甲骨文公司不再支持另一个自由软件项目OpenS olaris的发展，因此导致自由软件社区们对于Oracle是否还会持续支持MySQL社区版（MySQL之中唯一的免费版本）有所隐忧，因此原先一些使用MySQL的开源软件逐渐转向其它的数据库。例如维基百科已于2013年正式宣布将从MySQL迁移到MariaDB数据库。MySQL的创始人Monty Widenius以MySQL为基础，成立分支计划MariaDB 发展史 很多人以为MySQL是最近15年内才出现的数据库，其实MySQL数据库的历史可以追溯到1979年，那时 Bill Gates 退学没多久，微软公司也才刚刚起步，而Larry的Oracle公司也才成立不久。那时有一个天才程序员 Monty Widenius 用 BASIC 设计了一个报表工具，过了不久，又将此工具使用 C 语言重写，一直到 UNIX 平台，当时只是一个底层的面向报表存储引擎名叫Unireg 1985 年，瑞典的几位志同道合小伙子(David Axmark、Allan Larsson 和Monty Widenius) 成立了一家公司，这就是MySQL AB 的前身 1990年，TcX公司的客户中开始有人要求为他的API提供SQL支持。当时有人提议直接使用商用数据库，但是Monty觉得商用数据库的速度难以令人满意。于是，他直接借助于mSQL的代码，将它集成到自己的存储引擎中。令人失望的是，效果并不太令人满意，于是，Monty雄心大起，决心自己重写一个SQL支持 1996年，MySQL 1.0发布，它只面向一小拨人，相当于内部发布 1996年10月，MySQL 3.11.1发布(MySQL没有2.x版本)，最开始只提供Solaris下的二进制版本。一个月后，Linux版本出现了 1999～2000年，MySQL AB公司在瑞典成立。Monty雇了几个人与Sleepycat合作，开发出了Berkeley DB引擎, 因为BDB支持事务处理，所以MySQL从此开始支持事务处理了 2003年12月，MySQL 5.0版本发布，提供了视图、存储过程等功能 2008年1月16日，Sun（太阳微系统）正式收购MySQL 2009年4月20日，甲骨文公司宣布以每股9.50美元，74亿美元的总额收购Sun电脑公司 2010年12月，MySQL 5.5发布，其主要新特性包括半同步的复制及对SIGNAL/RESIGNAL的异常处理功能的支持，最重要的是InnoDB存储引擎终于变为当前MySQL的默认存储引擎 2013年6月18日，甲骨文公司修改MySQL授权协议，移除了GPL。但随后有消息称这是一个bug 版本 MySQL针对不同的用户，分了社区版和企业服务器版，还提供一些其它版本，是属于MySQL相关工具。 MySQL Community Server 社区版本，开源免费，但不提供官方技术支持 MySQL Enterprise Edition 企业版本，需付费，可以试用30天 MySQL Cluster 集群版，开源免费。可将几个MySQL Server封装成一个Server MySQL Cluster CGE 高级集群版，需付费 MySQL Workbench（GUI TOOL）一款专为MySQL设计的ER/数据库建模工具 MySQL 版本命命机制由三个数字组成，例如mysql-5.6.33-osx10.11-x86_64.tar.gz 第一个数字（5）主版本号：当你做了不兼容的 API 修改 第二个数字（7）次版本号：当你做了向下兼容的功能性新增，合计，主要和次要的数字构成发布系列号。该系列号描述了稳定的特征集 第三个数字（1）修订号：当你做了向下兼容的问题修正。这是一个新的bugfix释放增加。在大多数情况下，在一系列最新版本是最好的选择 优势 使用C和C++编写，并使用了多种编译器进行测试，保证源代码的可移植性 支持AIX、BSDi、FreeBSD、HP-UX、Linux、Mac OS、Novell NetWare、NetBSD、OpenBSD、OS/2 Wrap、Solaris、Windows等多种操作系统 为多种編程语言提供了API。这些編程语言包括C、C++、C#、VB.NET、Delphi、Eiffel、Java、Perl、PHP、Python、Ruby和Tcl等 支持多线程，充分利用CPU资源，支持多用户 優化的SQL查询算法，有效地提高查询速度 既能够作为一个单独的应用程序在客户端服务器网络环境中运行，也能够作为一个程序库而嵌入到其他的软件中 提供多语言支持，常见的编码如中文的GB2312、BIG5 UTF-8，日文的Shift JIS等都可以用作數據表名和數據列名 提供TCP/IP、ODBC和JDBC等多种数据库连接途径 提供用于管理、检查、优化数据库操作的管理工具 可以处理拥有上千万条记录的大型数据库 "},"MySQL/01-MySQL之概述.html":{"url":"MySQL/01-MySQL之概述.html","title":"MySQL之概述","keywords":"","body":"数据库简介 :jack_o_lantern: 数据(Data) 描述事物的符号记录称为数据，描述事物的符号既可以是数字、也可以是文字、图片、图像、声音、语言等，数据有多种表现形式，它们都可以经过数据化后存入计算机 数据库(DataBase,简称DB) 数据库即存储数据的仓库，只不过这个仓库是在计算机存储设备上，而且数据是按一定的格式存放的 数据库是长期存放在计算机内、有组织、可共享的数据集合 数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享 数据库管理系统(DataBase Management System,简称DBMS) 在了解了Data与DB的概念后，如何科学地组织和存储数据，如何高效获取和维护数据成了关键 这就用到了一个系统软件---数据库管理系统 如MySQL、Oracle、SQLite、Access、MS SQL Server mysql主要用于大型门户，例如搜狗、新浪等，它主要的优势就是开放源代码，因为开放源代码这个数据库是免费的，他现在是甲骨文公司的产品。 oracle主要用于银行、铁路、飞机场等。该数据库功能强大，软件费用高。也是甲骨文公司的产品。 sql server是微软公司的产品，主要应用于大中型企业，如联想、方正等。 数据库服务器、数据库管理系统、数据库、文件与数据的关系 数据库服务器-：运行数据库管理软件 数据库管理软件：管理-数据库 数据库：即文件夹，用来组织文件/表 文件：即表，用来存放多行内容/多条记录/多条数据 数据库管理技术的发展历程 人工管理阶段 20世纪50年代中期以前，计算机主要用于科学计算。 当时的硬件水平：外存只有纸带、卡片、磁带，没有磁盘等直接存取的存储设备 当时的软件状况：没有操作系统，没有管理数据的软件，数据的处理方式是批处理。 人工管理数据具有以下特点： 1、数据不保存：计算机主要用于科学计算，数据临时用，临时输入，不保存 2、应用程序管理数据：数据要有应用程序自己管理，应用程序需要处理数据的逻辑+物理结构，开发负担很重 3、数据不共享：一组数据只对应一个程序，多个程序之间涉及相同数据时，必须各自定义，造成数据大量冗余 4、数据不具有独立性：数据的逻辑结构或物理结构发生变化后，必须对应用程序做出相应的修改，开发负担进一步加大 文件系统阶段 20世纪50年代后期到60年代中期 硬件水平：有了磁盘、磁鼓等可直接存取的存储设备 软件水平：有了操作系统，并且操作系统中已经有了专门的数据管理软件，即文件系统；处理方式上不仅有了批处理，而且能够联机实时处理 文件系统管理数据具有以下优点 1、数据可以长期保存：计算机大量用于数据处理，因而数据需要长期保存，进行增删改查操作 2、由文件系统管理数据：文件系统这个软件，把数据组织成相对独立的数据文件，利用按文件名，按记录进行存取。实现了记录内的结构性，但整体无结构。并且程序与数据之间由文件系统提供存取方法进行转换，是应用程序与数据之间有了一定的独立性，程序员可以不必过多考虑物理细节 文件系统管理数据具有以下缺点： 1、数据共享性差，冗余度大：一个文件对应一个应用程序，不同应用有相同数据时，也必须建立各自的文件，不能共享相同的数据，造成数据冗余，浪费空间，且相同的数据重复存储，各自管理，容易造成数据不一致性 2 数据独立性差：一旦数据的逻辑结构改变，必须修改应用程序，修改文件结构的定义。应用程序的改变，也将引起文件的数据结构的改变。因此数据与程序之间缺乏独立性。可见，文件系统仍然是一个不具有弹性的无结构的数据集合，即文件之间是孤立的，不能反映现实世界事物之间的内存联系 数据系统阶段 20世纪60年代后期以来，计算机用于管理的规模越来越大，应用越来越广泛，数据量急剧增长，同时多种应用，多种语言互相覆盖地共享数据结合要求越来越强烈 硬件水平：有了大容量磁盘，硬件架构下降 软件水平：软件价格上升（开发效率必须提升，必须将程序员从数据管理中解放出来），分布式的概念盛行 数据库系统的特点： 1、数据结构化 2、数据共享，冗余度低，易扩充 3、数据独立性高 4、数据由DBMS统一管理和控制 　　a：数据的安全性保护 　　b：数据的完整性检查 　　c：并发控制 　　d：数据库恢复 SQL语 :jack_o_lantern: SQL(Structured Query Language)即结构化查询语言，数据库管理系统专门通过SQL语言来管理数据库中的数据，与数据库通信 SQL的优点 SQL不是某个特定数据库供应商专有的语言。几乎所有重要的 DBMS都支持SQL，所以，学习此语言使你几乎能与所有数据库 打交道 SQL简单易学。它的语句全都是由描述性很强的英语单词组成， 而且这些单词的数目不多 SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活 使用其语言元素，可以进行非常复杂和高级的数据库操作 DBMS专用的SQL：SQL不是一种专利语言，而且存在一个标准委员会，他们试图定义可供所有DBMS使用的SQL语法，但 事实上任意两个DBMS实现的SQL都不完全相同 SQL为数据库管理系统提供的功能 SQL语言是一种数据库查询和程序设计语言，其主要用于存取数据，查询数据，更新数据和管理数据库系统。具体的，SQL分为4个部分，这里只是大概整理一下，详细的后面我会在SQL相关中仔细整理 数据定义语言（Data Definition Language，DDL）：DROP、CREATE、ALTER等语句；数据库定义语言。主要用于定义数据库，表，视图，索引和触发器等。CREATE语句主要用于创建数据库，创建表，创建视图。ALTER语句主要用于修改表的定义，修改视图的定义。DROP语句主要用于删除数据库，删除表和删除视图等 数据操作语言（Data Manipulation Language，DML）：INSERT、UPDATE、DELETE语句；数据库操作语言。主要用于插入数据，更新数据，删除数据。INSERT语句用于插入数据，UPDATE语句用于更新数据，DELETE语句用于删除数据 数据查询语言（Data Query Language，DQL）：SELECT语句。主要用于查询数据 数据控制语言（Data Control Language ，DCL）语句：数据库控制语言。主要用于控制用户的访问权限。其中GRANT语句用于给用户增加权限，REVOKE语句用于收回用户的权限 数据库分类 :jack_o_lantern: 关系型数据库 关系型数据库(Relational database)，是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系模型是由埃德加·科德于1970年首先提出的，并配合“科德十二定律”。现如今虽然对此模型有一些批评意见，但它还是数据存储的传统标准。标准数据查询语言SQL就是一种基于关系数据库的语言，这种语言执行对关系数据库中数据的检索和操作 MySQL SQL Server Oracle Sybase 等等... 　　RDBMS:关系数据库管理系统(Relational Database Management System)的特点： ​ 1、数据以表格的形式出现 ​ 2、每行为各种记录名称 ​ 3、每列为记录名称所对应的数据域 ​ 4、许多的行和列组成一张表单 ​ 5、若干的表单组成database 几乎所有的数据库管理系统都配备了一个开放式数据库连接（ODBC）驱动程序，令各个数据库之间得以互相集成 非关系型数据库(NoSQL) NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。当代典型的关系数据库在一些数据敏感的应用中表现了糟糕的性能，例如为巨量文档创建索引、高流量网站的网页服务，以及发送流式媒体。关系型数据库的典型实现主要被调整用于执行规模小而读写频繁，或者大批量极少写访问的事务 MongoDB 　　MongoDB 是一个高性能，开源，无模式的文档型数据库，开发语言是C++。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式 Redis 　　Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。目前由VMware主持开发工作 MemCache 　　MemCache是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著。这是一套开放源代码软件，以BSD license授权发布 "},"MySQL/02-MySQL之基本操作.html":{"url":"MySQL/02-MySQL之基本操作.html","title":"MySQL之基本操作","keywords":"","body":"MySQL 用户及权限操作 :jack_o_lantern: 用户操作 更新root 用户的密码 set password for ‘root’@’localhost’ = password(‘新密码’) ps：用SET PASSWORD命令，此种方式适用于当前root用户没有密码的情况 UPDATE user SET Password = PASSWORD('newpass') WHERE user = 'root'; ps：用UPDATE直接编辑user表，此种方式不管有没有密码都可以进行修改 创建一个新用户,mysql授权用户以指定IP登录 create user ‘用户名’@’192.168.1.1’ identified by ‘密码’ ps:指定固定IP访问 create user ‘用户名’@’192.168.1.%’ identified by ‘密码’ ps:前面三位IP符合条件即可以访问 create user ‘用户名’@’%’ identified by ‘密码’ ps:没有IP限制,%表示通配所有IP 删除用户 drop user '用户名'@'IP' 修改用户 rename user '老用户名'@'IP' to '老用户名'@'IP' 丢失root密码 mysqld_safe --skip-grant-tables& ps: 在启动mysql时不启动grant-tables，授权表 mysql -u root mysql mysql> UPDATE user SET password=PASSWORD(\"new password\") WHERE user='root'; mysql> FLUSH PRIVILEGES; 用户授权 为用户授 指定权限 grant select,insert,update on 数据库.表名 to '用户名'@'%'; 为用户授 所有权限,除了root权限 grant all privileges on db1.t1 on 数据库.表名 to '用户名'@'%'; 刷新授权 FLUSH PRIVILEGES 去除权限； 12 revoke select on db_name.* from　'用户名'@'IP'; 库操作 :jack_o_lantern: 系统数据库 information_schema： 虚拟库，不占用磁盘空间，存储的是数据库启动后的一些参数，如用户表信息、列信息、权限信息、字符信息等 performance_schema： MySQL 5.5开始新增一个数据库：主要用于收集数据库服务器性能参数，记录处理查询请求时发生的各种事件、锁等现象 mysql：授权库，主要存储系统用户的权限信息 test：MySQL数据库系统自动创建的测试数据库 创建数据库 数据库命名规则 可以由字母、数字、下划线、＠、＃、＄ 区分大小写 唯一性 不能使用关键字如 create select 不能单独使用数字 最长128位 数据库操作 1.查看数据库 show databases; show create database db1; select database(); ps: 默认数据库： 　　mysql - 用户权限相关数据 　　test - 用于用户测试数据 　　information_schema - MySQL本身架构相关数据 2.选择数据库 USE 数据库名 3.创建数据库并设置编码集 create database 数据库名 character set ='utf8' 4.删除数据库 DORP DATABASE 数据库名; 5.修改数据库 alter database db1 charset utf8; 表操作 :jack_o_lantern: 表介绍 表相当于文件，表中的一条记录就相当于文件的一行内容，不同的是，表中的一条记录有对应的标题，称为表的字段 创建表 create table 表名( 字段名 类型[约束条件如：not null auto_increment primary key default 0], -- 非空、递增——唯一性，主键，默认列值 )ENGINE=InnoDB　　　　-- 设置表的存储引擎，一般常用InnoDB和MyISAM；InnoDB可靠，支持事务；MyISAM高效不支持全文检索 DEFAULT charset=utf8;　　-- 设置默认的编码，防止数据库中文乱码 -- 如果有条件的创建数据表还可以使用 CREATE TABLE IF NOT EXISTS 表名(........ 注意： 1. 在同一张表中，字段名是不能相同 2. 宽度和约束条件可选 3. 字段名和类型是必须的 修改表 1. 修改表名 ALTER TABLE 旧表名 RENAME 新表名; RENAME TABLE 旧表名 TO 新表名; 2. 增加字段 ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…], ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] FIRST; ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] AFTER 字段名; 3. 删除字段 ALTER TABLE 表名 DROP 字段名; 4. 修改字段 ALTER TABLE 表名 MODIFY 字段名 数据类型 [完整性约束条件…]; ALTER TABLE 表名 CHANGE 旧字段名 新字段名 旧数据类型 [完整性约束条件…]; ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型 [完整性约束条件…]; 复制表 复制表结构＋记录 （key不会复制: 主键、外键和索引） create table new_tablename select * from tablename; 或者部分复制： CREATE TABLE new1_tablename SELECT 字段名 FROM tablename; 只复制表结构 select * from tablename where 1=2; //条件为假，查不到任何记录 create table new1_tablename select * from tablename where 1=2; 查看表 SHOW TABALES; 删除表 DROP TABLE 表名; 清空表 truncate table 表名; 重命名表 RENAME TABLE 旧表名 TO 新表名; 还可以使用： ALTER TABLE 旧表名 RENAME 新表名; 数据操作 :jack_o_lantern: 新增 1. 插入完整数据（顺序插入） 语法一： INSERT INTO 表名(字段1,字段2,字段3…字段n) VALUES(值1,值2,值3…值n); 语法二： INSERT INTO 表名 VALUES (值1,值2,值3…值n); 2. 指定字段插入数据 语法： INSERT INTO 表名(字段1,字段2,字段3…) VALUES (值1,值2,值3…); 3. 插入多条记录 语法： INSERT INTO 表名 VALUES (值1,值2,值3…值n), (值1,值2,值3…值n), (值1,值2,值3…值n); 4. 插入查询结果 语法： INSERT INTO 表名(字段1,字段2,字段3…字段n) SELECT (字段1,字段2,字段3…字段n) FROM 表2 WHERE …; 修改 update table_name SET 字段名=更新值 WHERE 条件字段=条件值; 删除 DELETE FROM 表名称 WHERE 条件字段=条件值; 查询 单表查询 语法 SELECT 字段1,字段2... FROM 表名 WHERE 条件 GROUP BY field HAVING 筛选 ORDER BY field LIMIT 限制条数 关键字的执行优先级 重点中的重点：关键字的执行优先级 from where group by 聚合 having select distinct order by limit 1.找到表:from 2.拿着where指定的约束条件，去文件/表中取出一条条记录 3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组 4.将分组的结果进行having过滤 5.执行select 6.去重 7.将结果按条件排序：order by 8.限制结果的显示条数 WHERE约束 where字句中可以使用： 比较运算符：> = != between 10 and 20 值在10到20之间 in(10,20,30) 值是10或20或30 like 'timo%' pattern可以是%或_， %表示任意多字符 _表示一个字符 逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not 多表查询 外连接语法 SELECT 字段列表 FROM 表1 INNER|LEFT|RIGHT JOIN 表2 ON 表1.字段 = 表2.字段; 交叉连接：不适用任何匹配条件，生成笛卡尔乘积 select * from 表1,表2; 内连接：只连接匹配的行 #找两张表共有的部分，相当于利用条件从笛卡尔积结果中筛选出了正确的结果 pass 外链接之左连接：优先显示左表全部记录 #以左表为准，匹配所有结果 #本质就是：在内连接的基础上增加左边有右边没有的结果 pass 外链接之右连接：优先显示右表全部记录 #以右表为准，即找出所有部门信息，包括没有员工的部门 #本质就是：在内连接的基础上增加右边有左边没有的结果 pass 全外链接：显示左右两个表全部记录 全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果 注意： mysql不支持全外连接 full JOIN union与union all的区别：union会去掉相同的纪录 pass 子查询 1：子查询是将一个查询语句嵌套在另一个查询语句中。 2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。 3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字 4：还可以包含比较运算符：= 、 !=、> 、带IN关键字的子查询 select 字段名 from 表名 where 字段 in (select 查询语句); 带比较运算符的子查询 比较运算符：=、!=、>、>=、 select 字段名 from 表名 where 字段 > (select 查询语句); 带EXISTS关键字的子查询 EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。 而是返回一个真假值。True或False 当返回True时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询 select * from 表名 where exists (select 查询语句); "},"MySQL/03-MySQL之视图.html":{"url":"MySQL/03-MySQL之视图.html","title":"MySQL之视图","keywords":"","body":"MySQL 视图 :jack_o_lantern: 视图是一个虚拟表（非真实存在），其本质是【根据SQL语句获取动态的数据集，并为其命名】，用户使用时只需使用【名称】即可获取结果集，可以将该结果集当做表来使用。 使用视图我们可以把查询过程中的临时表摘出来，用视图去实现，这样以后再想操作该临时表的数据时就无需重写复杂的sql了，直接去视图中查找即可，但视图有明显地效率问题，并且视图是存放在数据库中的，如果我们程序中使用的sql过分依赖数据库中的视图，即强耦合，那就意味着扩展sql极为不便，因此并不推荐使用 视图的优点： ​ 1、简化表之间的联结（把联结写在select中） ​ 2、适当的利用视图可以更清晰地表达查询 ​ 3、过滤不想要的数据（select部分）视图能够对机密数据提供安全保护 ​ 4、使用视图计算字段值，如汇总这样的值 创建视图 语法： CREATE VIEW 视图名称 AS SQL语句 如： create view 视图名 as select 字段 from 表名 where 条件; 注意： 1. 使用视图以后就无需每次都重写子查询的sql，但是这么效率并不高，还不如我们写子查询的效率高 2. 而且有一个致命的问题：视图是存放到数据库里的，如果我们程序中的sql过分依赖于数据库中存放的视图，那么意味着，一旦sql需要修改且涉及到视图的部分，则必须去数据库中进行修改，而通常在公司中数据库有专门的DBA负责，你要想完成修改，必须付出大量的沟通成本DBA可能才会帮你完成修改，极其地不方便 使用视图 select * from 视图名称 更新视图数据 update 视图名 set 新数据 where 条件; insert into 视图名 values(数据); ps： 新增和修改视图数据，原始表也会跟着被修改 我们不应该修改视图中的记录，而且在涉及多个表的情况下是根本无法修改视图中的记录的 修改视图 ALTER VIEW 视图名称 AS SQL语句 删除视图数据 DELETE from 视图名 where 条件; 删除视图 drop view 视图名; 触发器 :jack_o_lantern: 触发器(trigger)：监视某种情况，并触发某种操作 触发器创建语法四要素：1.监视地点(table) 　　　　　　　　　　　2.监视事件(insert/update/delete) 　　　　　　　　　　　3.触发时间(after/before) 　　　　　　　　　　　4.触发事件(insert/update/delete) 使用触发器可以定制用户对表进行【增、删、改】操作时前后的行为，注意：没有查询 创建触发器 create trigger triggerName after/before insert/update/delete on 表名 for each row --这句话是固定的 begin 需要执行的sql语句 end 注意： 1.after/before: 只能选一个 ,after 表示 后置触发, before 表示前置触发 2.insert/update/delete:只能选一个 特别：NEW表示即将插入的数据行，OLD表示即将删除的数据行 使用触发器 触发器无法由用户直接调用，而是由于对表的【增/删/改】操作被动引发的 删除触发器 drop trigger 触发器名; 存储过程 :jack_o_lantern: 概念 什么是存储过程：类似于函数(方法),简单的说存储过程是为了完成某个数据库中的特定功能而编写的语句集合，该语句集包含了一系列SQL语句（对数据的增删改查）、条件语句和循环语句等，存储过程存放于MySQL中，通过调用它的名字可以执行其内部的一堆sql 使用存储过程的优点： 存储过程增强了SQL语言灵活性。存储过程可以使用控制语句编写，可以完成复杂的判断和较复杂的运算，有很强的灵活性； 减少网络流量，降低了网络负载。存储过程在数据库服务器端创建成功后，只需要调用该存储过程即可，而传统的做法是每次都将大量的SQL语句通过网络发送至数据库服务器端然后再执行； 存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。 系统管理员通过设定某一存储过程的权限实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全 用于替代程序写的SQL语句，实现程序与SQL解耦 使用存储过程的缺点： ​ 程序员扩展功能不方便 程序与数据库结合使用的三种方式 方式一： MySQL：存储过程 程序：调用存储过程 方式二： MySQL： 程序：纯SQL语句 方式三： MySQL: 程序：类和对象，即ORM（本质还是纯SQL语句） 查看现有存储过程 show procedure status; 删除存储过程 drop procedure 存储过程名称; 创建存储过程 对于存储过程，可以接收参数，其参数有三类： in 仅用于传入参数用 out 仅用于返回值用 inout 既可以传入又可以当作返回值 create procedure 存储过程名称( in/out/inout 参数名 参数类型, in/out/inout 参数名 参数类型 ) BEGIN 需要执行的SQL语句 END 调用存储过程 call 存储过程名称(参数1 参数类型,参数2 参数类型); 函数 :jack_o_lantern: 自定义函数 create FUNCTION 函数名(参数1 参数类型,参数2 参数类型) returns 参数类型 //设置返回类型 BEGIN DECLARE sum int default 0; set sum = i1+i2; return(sum); //返回结果 end 调用函数 直接调用自定义函数 select 函数名(参数1,参数2); 在sql语句中使用自定义函数 select 函数名(参数1,参数2),表字段 from 表名 删除函数 drop function 函数名; 事务 :jack_o_lantern: 什么是事务 ​ 事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。 ​ 事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前到事务开始时的所以操作。 　　总结:事务就是一组操作,要么全部完成,要么全部失败! 事物特性ACID 　　事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。 　　1 、原子性 (事物内的操作,要么全部成功,要么全部失败) ​ 事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 　　2 、一致性 (事物之前之后,前后数据的一致性) ​ 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态　如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 　　3 、隔离性(多个事物时,相互不能干扰) ​ 一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 　 4 、持续性(一旦事物提交(commit)之后,是不可回滚的) ​ 持续性也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 实例操作 ​ 1.开启事物 start transaction ​ 2.提交事物 commit ​ 3.回滚事物 rollback create table user( id int primary key auto_increment, name char(32), balance int ); insert into user(name,balance) values ('w',1000), ('l',1000), ('y',1000); #原子操作 start transaction; update user set balance=900 where name='w'; # w支付100元 update user set balance=1010 where name='l'; # l拿走10元 update user set balance=1090 where name='y'; # y家拿到90元 commit; #出现异常，回滚到初始状态 start transaction; update user set balance=900 where name='w'; # w支付100元 update user set balance=1010 where name='l'; # l拿走10元 uppdate user set balance=1090 where name='y'; # y拿到90元,出现异常没有拿到 rollback; commit; mysql> select * from user; +----+------+---------+ | id | name | balance | +----+------+---------+ | 1 | w | 1000 | | 2 | l | 1000 | | 3 | y | 1000 | +----+------+---------+ 3 rows in set (0.00 sec) 流程控制:jack_o_lantern: 条件语句 复制代码 delimiter // CREATE PROCEDURE proc_if () BEGIN declare i int default 0; if i = 1 THEN SELECT 1; ELSEIF i = 2 THEN SELECT 2; ELSE SELECT 7; END IF; END // delimiter ; 循环语句 delimiter // CREATE PROCEDURE proc_while () BEGIN DECLARE num INT ; SET num = 0 ; WHILE num repeat循环 delimiter // CREATE PROCEDURE proc_repeat () BEGIN DECLARE i INT ; SET i = 0 ; repeat select i; set i = i + 1; until i >= 5 end repeat; END // delimiter ; loop BEGIN declare i int default 0; loop_label: loop set i=i+1; if i=10 then leave loop_label; end if; select i; end loop loop_label; END "},"MySQL/04-MySQL之索引.html":{"url":"MySQL/04-MySQL之索引.html","title":"MySQL之索引","keywords":"","body":"MySQL 索引 :jack_o_lantern: 介绍 索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理，先定位到章，然后定位到该章下的一个小节，然后找到页数，可以帮助用户快速的找到需要的内容. 本质：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍，能够大大提高查询效率 　　索引优点:可以提高查询效率,而且是数据量越大效果越明显. 　　索引缺点:添加数据和删除数据效率低 类型 我们可以在创建索引的时候，为其指定索引类型，分两类 ​ hash类型的索引：查询单条快，范围查询慢 ​ btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它） 　　1、HASH :hash就是一种（key=>value）形式的键值对,允许多个key对应相同的value，但不允许一个key对应多个value,为某一列或几列建立hash索引，就会利用这一列或几列的值通过一定的算法计算出一个hash值，对应一行或几行数据. hash索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率 ​ 假设创建如下一个表： CREATE TABLE testhash ( 　　　　 fname VARCHAR(50) NOT NULL, 　　　　lname VARCHAR(50) NOT NULL, 　　　　KEY USING HASH(fname) 　　　　) ENGINE=MEMORY; ​ 包含的数据如下： 　　　　 ​ 假设索引使用hash函数f( )，如下： f('Arjen') = 2323 f('Baron') = 7437 f('Peter') = 8784 f('Vadim') = 2458 　　此时，索引的结构大概如下： 　　　 Slots是有序的，但是记录不是有序的。当你执行 　　mysql> SELECT lname FROM testhash WHERE fname='Peter'; MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f('Peter') = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。 因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。 ​ 2、BTREE: 就是一种将索引值按一定的算法，存入一个树形的数据结构中. 如二叉树一样 　　 不同的存储引擎支持的索引类型也不一样 InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引 MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引 Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引 NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引 Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引 分类 ​ 1.普通索引 ​ INDEX：加速查找 ​ 2.唯一索引 ​ UNIQUE:加速查找+约束（不能重复） ​ 3.主键索引 ​ PRIMARY KEY：加速查找+约束（不为空、不能重复） ​ 4.组合/联合索引 ​ PRIMARY KEY(id,name):联合主键索引 ​ UNIQUE(id,name):联合唯一索引 ​ INDEX(id,name):联合普通索引 ​ 5.FULLTEXT:全文索引 　　　　InnoDB引擎对FULLTEXT索引的支持是MySQL5.6新引入的特性，之前只有MyISAM引擎支持FULLTEXT索引，而且只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引. 　　　　FULLTEXT索引是按照分词原理建立索引的。西方文字中，大部分为字母文字，分词可以很方便的按照空格进行分割。但很明显，中文不能按照这种方式进行分词。这里介绍一个Mysql的中文分词插件Mysqlcft，有了它，就可以对中文进行分词，想了解的可以查看Mysqlcft，当然还有其他的分词插件可以使用。 MySQL索引管理 :jack_o_lantern: 创建索引 方法一：创建表时 　　CREATE TABLE 表名 ( 字段名1 数据类型 [完整性约束条件…], 字段名2 数据类型 [完整性约束条件…], [UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY [索引名] (字段名[(长度)] [ASC |DESC]) ); 方法二：CREATE在已存在的表上创建索引 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 ON 表名 (字段名[(长度)] [ASC |DESC]) ; 方法三：ALTER TABLE在已存在的表上创建索引 ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)] [ASC |DESC]) ; 普通索引 CREATE index 索引名 on 表名(添加索引的字段,多个字段以\",\"间隔) 唯一索引 CREATE UNIQUE index 索引名 on 表名(字段) 主键索引 alter table 表名 add primary key(字段); 注意:主键索引只能有一个 组合/联合索引 联合索引时指对表上的多个列合起来做一个索引。联合索引的创建方法与单个索引的创建方法一样，不同之处在仅在于有多个索引列，如下 create index 索引名 on 表名(字段,字段) 删除索引 DROP INDEX 索引名 ON 表名字; "},"Python/01-Basic Data Type.html":{"url":"Python/01-Basic Data Type.html","title":"Basic Data Type","keywords":"","body":"Basic data type str字符串:jack_o_lantern: 字符串的索引与切片 索引即下标，就是字符串组成的元素从第一个开始，初始索引为0以此类推 a = 'ABCDEFGHIJK' print(a[0]) print(a[3]) print(a[5]) print(a[7]) ​ 切片就是通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串（原则就是顾头不顾腚） a = 'ABCDEFGHIJK' print(a[0:3]) print(a[2:5]) print(a[0:]) #默认到最后 print(a[0:-1]) #-1就是最后一个 print(a[0:5:2]) #加步长 print(a[5:0:-2]) #反向加步长 int数字:jack_o_lantern: 主要用于计算 bit_length()　　当十进制用二进制表示时，转换成二进制时最少使用的位数 a=3 b=6 data=a.bit_length() data1=b.bit_length() print(data,data1) dict字典:jack_o_lantern: ​ 字典是python中唯一的映射类型，采用键值对（key-value）的形式存储数据。python对key进行哈希函数运算，根据计算的结果决定value的存储地址，所以字典是无序存储的，且key必须是可哈希的。可哈希表示key必须是不可变类型，如：数字、字符串、元祖 　　字典是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取 增 setdefault 在字典中添加键值对，如果只有键那对应的值是none,但是如果原字典中存在设置的键值对，则他不会更改或者覆盖 dic.setdefault('k','v') print(dic) dic.setdefault('k','v1') print(dic) # {'age': 18, 'name': 'jin', 'sex': 'male', 'k': 'v'} # {'age': 18, 'name': 'jin', 'sex': 'male', 'k': 'v'} 删 dic_pop = dic.pop(\"a\",'无key默认返回值') # pop根据key删除键值对，并返回对应的值，如果没有key则返回默认返回值 print(dic_pop) del dic[\"name\"] # 没有返回值。 print(dic) dic_pop1 = dic.popitem() # 随机删除字典中的某个键值对，将删除的键值对以元祖的形式返回 print(dic_pop1) # ('name','jin') dic_clear = dic.clear() # 清空字典 print(dic，dic_clear) # {} None 改 dic = {\"name\":\"jin\",\"age\":18,\"sex\":\"male\"} dic2 = {\"name\":\"alex\",\"weight\":75} dic2.update(dic) # 将dic所有的键值对覆盖添加（相同的覆盖，没有的添加）到dic2中 print(dic2) 查 value1 = dic['name'] # 没有会报错 print(value1) value2 = dic.get('djffdsafg','默认返回值') # 没有可以返回设定的返回值 print(value2) 其他 item = dic.items() print(item,type(item)) # dict_items([('name', 'jin'), ('sex', 'male'), ('age', 18)]) 这个类型就是dict_items类型，可迭代的 keys = dic.keys() print(keys,type(keys)) # dict_keys(['sex', 'age', 'name']) values = dic.values() print(values,type(values)) # dict_values(['male', 18, 'jin']) 同上 字典循环取key，value dic = {\"name\":\"jin\",\"age\":18,\"sex\":\"male\"} for key in dic: print(key) for item in dic.items(): print(item) for key,value in dic.items(): print(key,value） list列表:jack_o_lantern: 增 append(在列表最后的位置添加元素)：在原列表上进行增加 a=['alix','wusir','xiaofang'] a.append('laozi') print(a) # ['alex','wusir','xiaofang','laozi'] a=['alix','wusir','xiaofang'] while True: username=input('请输入员工姓名：') if username.lower()=='q': print('退出成功！') break else: a.append(username) print(a) 请输入员工姓名：ksdh ['alix', 'wusir', 'xiaofang', 'ksdh'] 请输入员工姓名：q 退出成功！ lnsert插入，可以在任意位置插入元素 insert(index,p_object) a=['taibai','jinxin','wusir'] a.insert(1,'太亮') print(a) # ['taibai','太亮'，'jinxin','wusir'] extend()：迭代的添加，加入列表的最后 a=['taibai','jinxin','wusir'] a.extend('太亮') b=['taibai','太亮','wusir'] b.extend(['金星']) print(a)　　　　　　 print(b)　　　　　　 # ['taibai','jinxin','wusir','太','亮'] # ['taibai','太亮'，'wusir','金星'] 　　如果extend()添加的是字符串，则字符串中的每个元素都会被拆分成单个的元素添加到目的列表中 　　如果extend()添加的是列表，则该列表会被当做一个整体添加到目的列表中成为目的列表中的一个元素 删 pop 按照索引去删除，有返回值 a=['taibai', '太亮', 'wusir', '金星'] name=a.pop(2) print(name)　　　　 print(a)　　　　　　 # wusir # ['taibai','太亮'，‘'金星'] ​ 删除的是a[2]=‘wusir’，返回值是wusir remove() 按元素来删除，但是没有返回值 a=['taibai', '太亮', 'wusir', '金星'] name=a.remove('taibai') print(name)　　 print(a)　　　 # None # ['太亮', 'wusir', '金星'] 　　由于remove()没有返回值，则输出name时得到的是0 clear() 清空列表，将列表变成空列表 a=['taibai', '太亮', 'wusir', '金星'] a.clear() print(a)　　　　 # [] 　　独立为一条语句，列表在进行clear()操作之后返回的是一个空列表，列表还在 del() 可以按照索引删除；也可以按照切片删除，可加步长。但是没有返回值 ​ 可以按照索引删除 a=['alix','taibai','tailiang','wusir'] del a[3] print(a) ['alix', 'taibai', 'tailiang'] 　　可以按照切片删除，也可以加步长 b=['alix','taibai','tailiang','wusir'] del b[1:3] print(b) ['alix', 'wusir'] 改 ​ 按照索引改：适用于修改单个元素的列表中 a=['alix','taibai','tailiang','wusir'] a[3]='亮亮' print(a) ['alix', 'taibai', 'tailiang', '亮亮'] 　　按照切片进行修改：先删除，之后迭代着添加 a=['alix','taibai','tailiang','wusir'] a[1:3]='都是一个人' print(a) ['alix', '都', '是', '一', '个', '人', 'wusir'] 　　该段代码是将列表中的a[1],a[2]先删除，之后将'都是一个人'从a[1]迭代着添加到列表a当中 　　该段代码是将a[1],a[2]现删除，之后将列表['都是一个人']添加到a[1]的位置 查 for循环查询 a=['alix', 'taibai', 'tailiang','wusir'] for i in a: print(i) alix taibai tailiang wusir 按索引查询 a=['alix', 'taibai', 'tailiang','wusir'] print(a[0]) print(a[1]) print(a[2]) print(a[3]) alix taibai tailiang wusir 列表的嵌套 列表可以被更改，字符串不可以被更改 a=['alix', 'taibai',[1,2,3,'yanger,old'], 'tailiang','wusir'] print(a[2]) print(a[2][2]) [1, 2, 3, 'yanger,old'] 3 将列表li的元素'yuanhao'的首字母变成大写，由于字符串不能被更改就只能将'yuanhao'提出之后形成一个新的首字母为大写的'Yuanhao'，之后再赋值给li[4] li=[1,2,3,'taibai','yuanhao',[1,'alix',3],True] print(li[3]) # taibai print(li[5][1]) # alix s=li[4].capitalize() li[4]=s print(li) # [1, 2, 3, 'taibai', 'Yuanhao', [1, 'alix', 3], True] 　　将li[4]中的'yuanhao'中的hao用'日天'来代替，由于'yuanhao'是字符串不能更改，所以只能是先提出li[4],之后形成一个新的字符串，将新的字符串赋值给li[4] li=[1,2,3,'taibai','yuanhao',[1,'alix',3],True] s2=li[4].replace('hao','日天') li[4]=s2 print(li) [1, 2, 3, 'taibai', 'yuan日天', [1, 'alix', 3], True] 对列表中的字符串进行'修改'和对列表中的元素进行修改。 li=[1,2,3,'taibai','yuanhao',[1,'alix',3],True] s2=li[4].replace('hao','日天') li[4]=s2 li[4]=li[4][0:4]+'ritian' print(li) # [1, 2, 3, 'taibai', 'yuanritian', [1, 'alix', 3], True] li[5][0]='文杰' print(li) # [1, 2, 3, 'taibai', 'yuanritian', ['文杰', 'alix', 3], True] li[5][1]=li[5][1].upper() print(li) # [1, 2, 3, 'taibai', 'yuanritian', ['文杰', 'ALIX', 3], True] 列表的叠加 li=[1,2,3] l2=['a','b','c'] l3=li+l2 print(l3) [1, 2, 3, 'a', 'b', 'c'] 其他方法 计数 count() li=[1,2,3,'taibai','yuanhao',[1,'alix',3],True] print(li.count('fsh')) print(li.count(1)) # 0 # 2 排序 　　正排序：sort() a=[1,2,3,7,4,8,0,3,9] a.sort() print(a) [0, 1, 2, 3, 3, 4, 7, 8, 9] 　　反转：reverse() 不排序，只是将原有列表中的元素按照与原来顺序相反的方式输出 a=[1,2,3,7,4,8,0,3,9] a.reverse() print(a) [9, 3, 0, 8, 4, 7, 3, 2, 1] tuple元祖:jack_o_lantern: 元组被称为只读列表，即数据可以被查询，但不能被修改，但字符串的切片操作同样适用于元组。例：（1，2，3）（\"a\",\"b\",\"c\"） a=(1,2,3) print(a[0]) print(a[1]) print(a[2]) 1 2 3 set集合:jack_o_lantern: ​ 集合是无序的，不重复的数据集合，它里面的元素是可哈希的（不可变类型），但集合本身是不可哈希的（所以集合做不了字典的键） 　　集合最重要的两点： 　　　　1.去重，把一个列表变成集合，就自动去重了 　　　　2.关系测试，测试两组数据之前的交集、并集、差集等关系 增 set1 = {'alex', 'wusir', 'ritian','barry'} set1.add('景女神')　　#增加一个元素 print(set1) update：迭代的增加 set1.update('A') print(set1) set1.update('老师') print(set1) set1.update([1,2,3]) print(set1) 删 set1 = {'alex','wusir','ritian','egon','barry'} set1.remove('alex') #删除一个元素 print(set1) set1.pop() #随机删除一个元素 print(set1) set1.clear() #清空集合 print(set1) del set1 #删除集合 print(set1) 查 集合的查询只能用for循环操作 set = {1,2,3} for i in set: print(i) 1 2 3 其他操作 交集（&或者intersectiion） set1 = {1,2,3,4,5} set2 = {4,5,6,7,8} print(set1 & set2) print(set1.intersection(set2)) 并集（| 或者union） set1 = {1,2,3,4,5} set2 = {4,5,6,7,8} print(set1 | set2) print(set1.union(set2)) 差集（-或者difference） set1 = {1,2,3,4,5} set2 = {4,5,6,7,8} print(set1- set2) print(set1.difference(set2)) 反交集（^或者symmetric_difference） set1 = {1,2,3,4,5} set2 = {4,5,6,7,8} print(set1 ^ set2) print(set1.symmetric_difference(set2)) 子集与超集 set1 = {1,2,3} set2 = {1,2,3,4,5,6} print(set1set1) print(set2.issuperset(set1))#这两个相同说明set2是set1的超集 frozenset frozenset不可变集合，让集合变成不可变类型 s = frozenset('barry') print(s,type(s)) #frozenset({'r', 'a', 'b', 'y'}) bool布尔值:jack_o_lantern: bool只有True、真和False、假两种表现形式，就是反应条件的正确与否 　　真 1 True 　　假 0 False "},"Python/02-File Operations.html":{"url":"Python/02-File Operations.html","title":"File Operations","keywords":"","body":"File Operations "},"Python/03-Function.html":{"url":"Python/03-Function.html","title":"Function","keywords":"","body":"Function 定义 将代码封装起来 #函数定义 def my_len(): s1='hello world' length=0 for i in s1: length=length+1 print(length) my_len() #函数调用 # 11 ​ def关键词开头，空格之后接函数名称和圆括号(),最后还有一个“：” ​ def是固定的，不能变，必须是连续的def三个字母，不能分开 ​ 空格 为了将def关键字和函数名称分开，必须空 ​ 函数名：函数名只能包含字符串、下划线和数字且不能以数字开头。虽然函数名可以随便起，但我们给函数起名字还是要尽量简短，并表达函数功能 ​ 括号：必须要有 注释 每一个函数都应该对功能和参数进行相应的说明，应该写在函数下面第一行。以增强代码的可读性 调用 函数名() 返回值 在调用python自带的len函数时，必须用一个变量来接收这个值 str_len=len('hello,word') 使用自己写的函数也可以做到这一点 # 函数定义 def my_len(): s1='hello world' length=0 for i in s1: length=length+1 print(length) str_len=my_len() #函数调用 print('str_len:%s'%str_len) # 11 # str_len:None 说明这段代码什么都没有返回 ​ 在写函数的时候，要尽量以功能为向导，结果最好不要直接在函数中打印出来 关键字return ​ 1、返回一个值 　　2、终止一个函数的继续 def my_len(): # 函数名的定义 s1='hello world' length=0 for i in s1: length=length+1 return length # 函数的返回值 str_len=my_len() #函数的调用以及返回值的接收 print(str_len) # 11 在没有返回值的时候 　　1、不写return与写入return None的效果相同，返回的只都是None　　　 　　2、只写一个return后面不加任何东西的时候与写return None的效果一样 返回多个值 ​ 1、当用一个变量接收返回值的时候，收到的是一个元组。这是因为在python中把用逗号分割的 多个值认为是一个元组 ​ 2、当返回值有多个变量接收，那么返回值的个数应该和接收变量的个数完全一致 #返回多个值，用一个变量接收 def f(): return 'a','b' c=f() print(c) # ('a', 'b') #返回多个值，用多个变量接收(接收的变量数与返回值的个数要一致) c,d=f() print(c,d) # a b return的扩展 def f(l): if len(l)>4: return True else: return False s=[1,2,3,4] dic={5,6,7,8,9} print(f(s)) print(f(dic)) # False # True 参数 #函数定义 def fun(s): count=0 for i in s: count+=1 return count #函数调用 str=fun('jshdjkshkdhsk') print(str) #13 ​ 在上述代码中，告诉了fun函数要计算的字符串是谁，这个过程就是传递参数，简称传参；在调用函数时传递的这个'jshdjkshkdhsk'和定义函数时的s就是参数 实参 ​ 在调用函数时传递的'jshdjkshkdhsk'被称为实际参数，因为这个是实际要交给函数的内容，简称实参 形参 ​ 定义s的时候，s只是一个变量的名字，被称为形式参数，因为在定义函数的时候它只是一个形式，表示这里有一个参数，简称形参。 ​ 在传递多个参数：多个函数分别可以使用任意数据类型 ​ 按照关键之传参数和按照位置传参数是可以混用的，但是首先都是按位置传，之后再是按关键字传的；按照位置传完该接收的参数只能接收一个值，不接受或者重复接收 def f2(arge1,arge2): # 站在接收、形参的角度上：位置参数 print(arge1) print(arge2) f2('abc',arge2=[1,2,3]) # abc # [1, 2, 3] def f2(arge1,arge2): print(arge1) print(arge2) f2('abc',{'jsdj'}) # abc # {'jsdj'} 默认参数 ​ 可以不传的参数，在不传参数的情况下可以使用默认值；如果传了，就会使用传的值 def classmate(name,sex='男'): print('姓名：%s,性别：%s'%(name,sex)) classmate('张三') classmate('李四') classmate('翠花','女') # 姓名：张三,性别：男 # 姓名：李四,性别：男 # 姓名：翠花,性别：女 默认参数魔性用法 ​ 默认参数尽量避免使用可变数据类型 def fun(l=[]): # 相当于在def之前先定义了一个str=[],再将str赋值给l l.append(2) print(l) fun() fun() fun() fun() # [2] # [2, 2] # [2, 2, 2] # [2, 2, 2, 2] def fun(l=[]): # 相当于在def之前先定义了一个str=[],再将str赋值给l l.append(2) print(l) fun([]) fun([]) fun([]) fun([]) # [2] # [2] # [2] # [2] 动态参数 按位置传值多余的参数都由args统一接收，保存成一个元组或字典的形式 *args：接收所有按照位置传的参数 #位置参数 动态参数 def func(a,b,c,*args): # 在参数前面加个*，这个参数就变成了动态参数 print(a,b,c) print(args) # 使用的时候，所有接收过来的参数都被组织成一个元组的形式 func(2,3,4,'jsk',[1,2,3]) # 2 3 4 # ('jsk', [1, 2, 3]) #位置参数 动态参数 默认参数 def func(a,b,c,*args,key='key'): # 在参数前面加个*，这个参数就变成了动态参数 print(a,b,c) print(key) print(args) # 使用的时候，所有接收过来的参数都被组织成一个元组的形式 func(2,3,4,'jsk',[1,2,3],'xiaoming') # 2 3 4 # key # ('jsk', [1, 2, 3],'xiaoming') *args魔性用法 def sum(*args): # *args的作用是聚合，将传入的参数转变成元组的形式 print(args) sun=0 for i in args: sun+=i return sun l=[1,2,34,5] print(sum(*l)) # *l 是将列表l打散之后变成将列表中的每个元素分别输出 # (1, 2, 34, 5) # 42 \\kwargs：按照所有接收关键字传的参数 def func(a,*args,key='key',**kwargs): print(a) print(args) print(key) print(kwargs) func(1,b=2,key='key') func(5) # 1 # () # key # {'b': 2} # 5 # () # key # {} 三元运算 a=1 b=7 c=0 if a>b: c=a else: c=b print(c) ​ 三元运算表达式，与以上代码的作用效果相同 c=0 a=1 b=7 c=a if a>b else b # 如果a>b成立，则c==a,否则c==b print(c) "},"Python/04-Function Advanced.html":{"url":"Python/04-Function Advanced.html","title":"Function Advanced","keywords":"","body":"Function advanced 序言:jack_o_lantern: ​ 从Python解释器开始执行之后，就在内存中开辟了一个空间每当遇到一个变量的时候，就把变量名和值之间的对应关系记录下来。 ​ 但是当遇到函数定义的时候解释器只是象征性的将函数名读入内存，表示知道这个函数的存在了，至于函数内部的变量和逻辑解释器根本不关心。 ​ 等执行到函数调用的时候，Python解释器会再开辟一块内存来存储这个函数里的内容，这个时候，才关注函数里面有哪些变量，而函数中的变量会存储在新开辟出来的内存中。函数中的变量只能在函数的内部使用，并且会随着函数执行完毕，这块内存中的所有内容也会被清空。 ​ 我们给这个“存放名字与值的关系”的空间起了一个名字——叫做命名空间 ​ 代码在运行伊始，创建的存储“变量名与值的关系”的空间叫做全局命名空间，在函数的运行中开辟的临时的空间叫做局部命名空间 命名空间和作用域:jack_o_lantern: 命名空间 命名空间的本质：存放名字与值的绑定关系 #Python之禅 >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! 在Python之禅中提到过：命名空间是一种绝妙的理念，让我们尽情的使用发挥吧！ 命名空间一共分为三种： ​ 全局命名空间 ​ 局部命名空间 ​ 内置命名空间 内置命名空间中存放了Python解释器为我们提供的名字：input,print,str,list,tuple...它们都是我们熟悉的，拿过来就可以用的方法。 三种命名空间之间的加载与取值顺序： 加载顺序：内置命名空间(程序运行前加载)->全局命名空间(程序运行中：从上到下加载)->局部命名空间(程序运行中：调用时才加载) 取值： 　　在局部调用：局部命名空间->全局命名空间->内置命名空间 #在局部使用变量取值情况 x = 1 def f(x): print(x) print(10) ​ 在全局调用：全局命名空间->内置命名空间 #在全局引用变量 x = 1 def f(x): print(x) f(10) print(x) #在全局引用内置max print(max) 作用域 作用域就是作用范围，按照生效范围可以分为全局作用域和局部作用域。 全局作用域：包含内置名称空间、全局名称空间，在整个文件的任意位置都能被引用、全局有效 局部作用域：局部名称空间，只能在局部范围内生效 globals和locals方法 #在全局调用globals和locals print(globals()) print(locals()) #在局部调用globals和locals def func(): a = 12 b = 20 print(locals()) print(globals()) func() global关键字 a = 10 def func(): global a a = 20 print(a) func() print(a) 函数的嵌套和作用域链 函数的嵌套调用 def max2(x,y): m = x if x>y else y return m def max4(a,b,c,d): res1 = max2(a,b) res2 = max2(res1,c) res3 = max2(res2,d) return res3 # max4(23,-7,31,11) 函数的嵌套定义 def f1(): print(\"in f1\") def f2(): print(\"in f2\") f2() f1() def f1(): def f2(): def f3(): print(\"in f3\") print(\"in f2\") f3() print(\"in f1\") f2() f1() 函数的作用域链 def f1(): a = 1 def f2(): print(a) f2() f1() def f1(): a = 1 def f2(): def f3(): print(a) f3() f2() f1() def f1(): a = 1 def f2(): a = 2 f2() print('a in f1 : ',a) f1() nonlocal关键字 ​ 1.外部必须有这个变量 ​ 2.在内部函数声明nonlocal变量之前不能再出现同名变量 ​ 3.内部修改这个变量如果想在外部有这个变量的第一层函数中生效 def f1(): a = 1 def f2(): nonlocal a a = 2 f2() print('a in f1 : ',a) f1() 函数名的本质 函数名本质上就是函数的内存地址 1.可以被引用 def func(): print('in func') f = func print(f) 2.可以被当作容器类型的元素 def f1(): print('f1') def f2(): print('f2') def f3(): print('f3') l = [f1,f2,f3] d = {'f1':f1,'f2':f2,'f3':f3} #调用 l[0]() d['f2']() 3.可以当作函数的参数和返回值 *不明白？那就记住一句话，就当普通变量用 第一类对象（first-class object）指 1.可在运行期创建 2.可用作函数参数或返回值 3.可存入变量的实体。 闭包 闭包函数： ​ 内部函数包含对外部作用域而非全剧作用域名字的引用，该内部函数称为闭包函数 ​ 函数内部定义的函数称为内部函数 def func(): name = 'eva' def inner(): print(name) 由于有了作用域的关系，我们就不能拿到函数内部的变量和函数了。如果我们就是想拿怎么办呢？返回呀！ 我们都知道函数内的变量我们要想在函数外部用，可以直接返回这个变量，那么如果我们想在函数外部调用函数内部的函数呢？是不是直接就把这个函数的名字返回就好了？ 这才是闭包函数最常用的用法 def func(): name = 'eva' def inner(): print(name) return inner f = func() f() 判断闭包函数的方法closure #输出的__closure__有cell元素 ：是闭包函数 def func(): name = 'eva' def inner(): print(name) print(inner.__closure__) return inner f = func() f() #输出的__closure__为None ：不是闭包函数 name = 'egon' def func2(): def inner(): print(name) print(inner.__closure__) return inner f2 = func2() f2() 闭包嵌套 def wrapper(): money = 1000 def func(): name = 'eva' def inner(): print(name,money) return inner return func f = wrapper() i = f() i() 闭包函数获取网络应用 from urllib.request import urlopen def index(): url = \"http://www.xiaohua100.cn/index.html\" def get(): return urlopen(url).read() return get xiaohua = index() content = xiaohua() print(content) 总结:jack_o_lantern: 命名空间： 　　一共有三种命名空间从大范围到小范围的顺序：内置命名空间、全局命名空间、局部命名空间 作用域（包括函数的作用域链）： 小范围的可以用大范围的 但是大范围的不能用小范围的 范围从大到小（图） 在小范围内，如果要用一个变量，是当前这个小范围有的，就用自己的 如果在小范围内没有，就用上一级的，上一级没有就用上上一级的，以此类推。 如果都没有，报错 函数的嵌套： 　　嵌套调用 　　嵌套定义：定义在内部的函数无法直接在全局被调用 函数名的本质： 　　就是一个变量，保存了函数所在的内存地址 闭包： 　　内部函数包含对外部作用域而非全剧作用域名字的引用，该内部函数称为闭包函数 "},"Python/05-Recursion.html":{"url":"Python/05-Recursion.html","title":"Recursion","keywords":"","body":"Rcursion Function 递归的定义:jack_o_lantern: 在一个函数里再调用这个函数本身 递归最大深度:jack_o_lantern: 递归函数如果不受外力的阻止就会一直执行下去，但每一次函数调用都会产生一个属于它自己的名称空间，如果一直调用下去，就会造成名称空间占用太多内存的问题，于是Python为了杜绝此类现象，强制的将递归层数控制在了997 #测试最大递归深度 def foo(n): print(n) n += 1 foo(n) foo(1) 当然，997是Python为了我们程序的内存优化所设定的一个默认值，我们还是可以通过一些方式修改默认值的 #修改递归最大深度 import sys print(sys.setrecursionlimit(100000)) 不过不推荐修改默认递归深度，因为如果用997层递归都没有解决的问题不是代码太烂那就是不适合使用递归来解决 递归示例:jack_o_lantern: 二分查找算法 定义：二分查找又称折半查找 优点：比较次数少，查找速度快，平均性能好 缺点：要求待查表为有序表，且执行插入删除操作困难 因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设列表中元素是按升序排列，将列表中间位置记录的值与所需查找的值比较，如果两者相等，则查找成功；否则利用中间位置记录将列表分成前、后两个子表，如果中间位置记录的值大于需要查找的值，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，查找成功，或直到子表不存在为止，此时查找不成功 #简单版 l = [2,3,5,10,15,16,18,22,26,30,32,35,41,42,43,55,56,66,67,69,72,76,82,83,88] def func(l,aim): mid = (len(l)-1)//2 if l: if aim > l[mid]: func(l[mid+1:],aim) elif aim #优化版 def find_2(l,aim,start=0,end=None): if end == None:end = len(l) - 1 if start aim: find_2(l,aim,start,mid-1) elif l[mid] 阶乘 def f(n): if n==1: return 1 return n*f(n-1) print(f(3)) # 6 斐波那契数列 def fib(n): if n==1 or n==2: return 1 return fib(n-1)+fib(n-2) print(fib(8)) # 21 三级菜单 menu = { '北京': { '海淀': { '五道口': { 'soho': {}, '网易': {}, 'google': {} }, '中关村': { '爱奇艺': {}, '汽车之家': {}, 'youku': {}, }, '上地': { '百度': {}, }, }, '昌平': { '沙河': { '老男孩': {}, '北航': {}, }, '天通苑': {}, '回龙观': {}, }, '朝阳': {}, '东城': {}, }, '上海': { '闵行': { \"人民广场\": { '炸鸡店': {} } }, '闸北': { '火车战': { '携程': {} } }, '浦东': {}, }, '山东': {}, } def menu_3(menu): while True: for key in menu: print(key) choice=input('选择:') if choice == 'q' or choice == 'b': return choice elif choice in menu and menu_3(menu[choice]): borq = menu_3(menu[choice]) if borq == 'q': return 'q' menu_3(menu) "},"Python/06-Decorator.html":{"url":"Python/06-Decorator.html","title":"Decorator","keywords":"","body":"Decorator 本质:jack_o_lantern: 装饰器的本质——一个闭包函数 功能:jack_o_lantern: 装饰器的功能——在不修改原函数本身及其调用方式的前提下在函数前后添加功能 形成:jack_o_lantern: #装饰器简单版 import time def func1(): print('in func1') def timer(func): def inner(): start = time.time() func() print(time.time() - start) return inner func1 = timer(func1) func1() 为了省略上面那一次赋值调用，python为我们提供了一句语法糖来解决这个问题 #装饰器————语法糖 import time def timer(func): def inner(): start = time.time() func() print(time.time() - start) return inner @timer #==> func1 = timer(func1) def func1(): print('in func1') func1() #带参数的装饰器 def timer(func): def inner(a): start = time.time() func(a) print(time.time() - start) return inner @timer def func1(a): print(a) func1(1) #hold所有函数传参 import time def timer(func): def inner(*args,**kwargs): start = time.time() re = func(*args,**kwargs) print(time.time() - start) return re return inner @timer #==> func1 = timer(func1) def func1(a,b): print('in func1') @timer #==> func2 = timer(func2) def func2(a): print('in func2 and get a:%s'%(a)) return 'fun2 over' func1('aaaaaa','bbbbbb') print(func2('aaaaaa')) #带返回值的装饰器 import time def timer(func): def inner(*args,**kwargs): start = time.time() re = func(*args,**kwargs) print(time.time() - start) return re return inner @timer #==> func2 = timer(func2) def func2(a): print('in func2 and get a:%s'%(a)) return 'fun2 over' func2('aaaaaa','bbbbbb') print(func2('aaaaaa')) #多个装饰器装饰同一个函数 def wrapper1(func): def inner(): print('wrapper1 ,before func') func() print('wrapper1 ,after func') return inner def wrapper2(func): def inner(): print('wrapper2 ,before func') func() print('wrapper2 ,after func') return inner @wrapper2 @wrapper1 def f(): print('in f') f() 正常情况下一些查看函数信息的方法都会在装饰器这里失效 #查看函数信息 def index(): '''这是一个主页信息''' print('from index') print(index.__doc__) #查看函数注释的方法 print(index.__name__) #查看函数名的方法 为了不让它们失效，需要在装饰器上加上一点来完善 #装饰器————wraps from functools import wraps def deco(func): @wraps(func) #加在最内层函数正上方 def wrapper(*args,**kwargs): return func(*args,**kwargs) return wrapper @deco def index(): '''哈哈哈哈''' print('from index') print(index.__doc__) print(index.__name__) 开放封闭原则:jack_o_lantern: ​ 对扩展是开放的 ​ 任何一个程序，不可能在设计之初就已经想好了所有的功能并且在未来不做任何关心和修改，所以必须允许代码扩展、添加新功能 ​ 对修改是封闭的 ​ 我们所写的程序都是要交给用户使用的，如果我们随意对其进行修改，很有可能影响已经在使用程序的用户 ​ 装饰器完美的遵循了开放封闭原则 "},"Python/07-Object-Oriented.html":{"url":"Python/07-Object-Oriented.html","title":"Object-Oriented","keywords":"","body":"Object-Oriented 面向过程vs面向对象:jack_o_lantern: 面向过程的程序设计核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西 优点：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可 缺点：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身 面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取。 优点：解决了程序的扩展性，对某一个对象单独修改，会立刻反映整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易 缺点：可控性差，无法像面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人物一参数的修改极有可能导致bug技能的出现，一刀砍死多个人，这个游戏就失去平衡 应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。 在python 中面向对象的程序设计并不是全部。 面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。 了解一些名词：类、对象、实例、实例化 类：具有相同特征的一类事物(人、狗、老虎) 对象／实例：具体的某一个事物（隔壁阿花、楼下旺财） 实例化：类——>对象的过程 初始类和对象 python中一切皆为对象，类型的本质就是类 类：一类具有相同属性和方法的事物 字典 _ 类 d1 = {'k1':'v1'} #对象 #动物园：老虎 狮子 猴 在python中，用变量表示特征，用函数表示技能，因而具有相同特征和技能的一类事物就是类，对象则是这一类事物中具体的一个 类 lass Person: #类名有两个作用 country = '中国' #静态属性、数据属性 def walk(self): #动态属性、函数属性、方法 print('walk') ​ 类的两种作用：属性引用和实例化 属性引用（类名.属性） class Person: country = '中国' def walk(self): print('walk') 1.属性引用 print(Person.country) #静态属性的查看 print(Person.walk) Person.role = '人' #添加一个新静态属性 Person.country = '印度' #修改一个新静态属性 del Person.role #删除一个静态属性 print(Person.__dict__) print(Person.walk()) #报错 少self参数 Person.__dict__['country'] = '印度' #报错 不能改变 print(Person.__dict__['country']) print(Person.country) 实例化（类名加括号就是实例化，会自动触发init函数的运行，可以用它来为每个实例定制自己的特性） class Person: #类名有两个作用 country = '中国' #静态属性、数据属性 def walk(self): #动态属性、函数属性、方法 print('walk') #类能完成的第二个功能：实例化对象 #实例化：从一个类中创造一个具体的对象的过程 p = Person() print(p) #Person的对象 　　实例化的过程就是类——对象的过程 对象 class Person: def __init__(self,life_value,aggr,name,job): self.life = life_value self.aggressive = aggr self.name = name self.job = job def attack(self,dog_obj): #boss_gold,tiedan print('%s 攻击了 %s'%(self.name,dog_obj.name)) dog_obj.life = dog_obj.life - self.aggressive ​ 对象是关于类而实际存在的一个例子，即实例 ​ 对象/实例只有一种作用：属性引用 boss_gold = Person(100,2.5,'太黑','old_driver') print(boss_gold.life) 对象之间的交互 #人类 ： # 属性 ：life_value,aggr,name,job # 方法： attack class Person: def __init__(self,life_value,aggr,name,job): self.life = life_value self.aggressive = aggr self.name = name self.job = job def attack(self,dog_obj): #boss_gold,tiedan print('%s 攻击了 %s'%(self.name,dog_obj.name)) dog_obj.life = dog_obj.life - self.aggressive #狗类: # 属性：life_value,aggr,name,kind # 方法：bite class Dog: def __init__(self,life_value,aggr,name,kind): self.life = life_value self.aggressive = aggr self.name = name self.kind = kind def bite(self,person_obj): print('%s 咬了 %s' % (self.name, person_obj.name)) person_obj.life -= self.aggressive tiedan = Dog(1000,100,'铁蛋','土狗') boss_gold = Person(100,2.5,'太黑','old_driver') # boss_gold.attack(tiedan) #Person.attack(boss_gold,tiedan) # print(tiedan.life) # tiedan.bite(boss_gold) # print(boss_gold.life) 类命名空间与对象、实例的命名空间 创建一个类就会创建一个类的名称空间，用来存储类中定义的所有名字，这些名字称为类的属性 类有两种属性：静态属性和动态属性 　　　　静态属性就是直接在类中定义的变量 　　　　动态属性就是定义在类中的方法 其中类的数据属性是共享给所有对象的 而类的动态属性是绑定到所有对象的 创建一个对象/实例就会创建一个对象/实例的名称空间，存放对象/实例的名字，称为对象/实例的属性 在obj.name会先从obj自己的名称空间里找name，找不到则去类中找，类也找不到就找父类...最后都找不到就抛出异常 组合用法 软件重用的重要方式除了继承之外还有另外一种方式，即：组合 组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合 class Person: # 定义一个人类 def __init__(self, name, aggressivity, life_value, money): self.name = name # 每一个角色都有自己的昵称; self.aggressivity = aggressivity # 每一个角色都有自己的攻击力; self.life_value = life_value # 每一个角色都有自己的生命值; self.money = money def attack(self,dog): dog.life_value -= self.aggressivity def get_weapon(self,weapon_obj): if self.money > weapon_obj.price: self.money -= weapon_obj.price # 金老板花钱买武器 self.weapon = weapon_obj # 金老板装备打狗棒 self.aggressivity += weapon_obj.aggr # 金老板的攻击力增加了 # boss_gold = Person('金老板',5,250,100) # huang = Dog('大黄','藏獒',100,3000) # huang.bite(boss_gold) # print(boss_gold.life_value) # boss_gold.attack(huang) # print(huang.life_value) #武器装备 #人 有 武器 —— 组合 #武器：攻击力，名字，价格 class Weapon: def __init__(self,name,price,aggr): self.name = name self.price = price self.aggr = aggr dgb = Weapon('打狗棒',99.8,100) boss_gold = Person('金老板',5,250,100) huang = Dog('大黄','藏獒',100,3000) boss_gold.get_weapon(dgb) boss_gold.attack(huang) print(huang.life_value) 圆环是由两个圆组成的，圆环的面积是外面圆的面积减去内部圆的面积。圆环的周长是内部圆的周长加上外部圆的周长。 这个时候，我们就首先实现一个圆形类，计算一个圆的周长和面积。然后在\"环形类\"中组合圆形的实例作为自己的属性来用 #圆形类 from math import pi class Circle: def __init__(self,r): self.radius = r def perimeter(self): return 2*pi*self.radius def area(self): return pi*(self.radius**2) #环形类 class Ring: def __init__(self,outer_r,inner_r): self.outer_circle = Circle(outer_r) self.inner_circle = Circle(inner_r) def perimeter(self): return self.outer_circle.perimeter()+self.inner_circle.perimeter() def area(self): return self.outer_circle.area() - self.inner_circle.area() 用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系,比如老师有生日 class Teacher: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex # self.birth_year = year class Birthday: def __init__(self,year,month,day): self.year = year self.month = month self.day = day birthay1 = Birthday(1968,12,31) boss_gold = Teacher('太亮',40,'不详') boss_gold.birth = birthay1 boss_gold.birth.year #boss_gold.bith.year #老师有生日 ： 年月日 #将一个类的对象拥有的属性 再将其定义成一个类以提高代码的复用 class Teacher: def __init__(self,name,age,sex,year,month,day): self.name = name self.age = age self.sex = sex self.birth = Birthday(year,month,day) class Birthday: def __init__(self,year,month,day): self.year = year self.month = month self.day = day boss_gold = Teacher('太亮',40,'不详',1968,12,31) print(boss_gold.birth) ​ 当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好 三大特性:jack_o_lantern: 继承 继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类 python中类的继承分为：单继承和多继承 # 继承 ：至少两个类 ： 什么 是 什么 的关系,为了避免几个类之间有相同的代码 # 父类 ： Animal # 子类 ： Dog、Person #动物 class Animal: def __init__(self,name,aggressivity,life_value): self.name = name self.aggressivity = aggressivity self.life_value = life_value #狗 class Dog(Animal): # 定义一个狗类 def bite(self,people): people.life_value -= self.aggressivity #人 class Person(Animal): # 定义一个人类 def attack(self,dog): dog.life_value -= self.aggressivity def get_weapon(self,weapon_obj): if self.money > weapon_obj.price: self.money -= weapon_obj.price # 金老板花钱买武器 self.weapon = weapon_obj # 金老板装备打狗棒 self.aggressivity += weapon_obj.aggr # 金老板的攻击力增加了 huang = Dog('大黄',100,3000) #__init__ 找父类 print(huang.life_value) boss_gold = Person('金老板',5,250) #__init__ 自己没有 找父类 print(boss_gold.life_value) # Dog.bite(Person) print(Dog.__bases__) print(Animal.__bases__) 继承与抽象（先抽象再继承） 抽象即抽取类似或者说比较像的部分。 抽象分成两个层次： 1.将奥巴马和梅西这俩对象比较像的部分抽取成类； 2.将人，猪，狗这三个类比较像的部分抽取成父类。 抽象最主要的作用是划分类别（可以隔离关注点，降低复杂度） 继承：是基于抽象的结果，通过编程语言去实现它，肯定是先经历抽象这个过程，才能通过继承的方式去表达出抽象的结构 抽象只是分析和设计的过程中，一个动作或者说一种技巧，通过抽象可以得到类 继承与重用性 在开发程序的过程中，如果我们定义了一个类A，然后又想新建立另外一个类B，但是类B的大部分内容与类A的相同时 我们不可能从头开始写一个类B，这就用到了类的继承的概念。 通过继承的方式新建类B，让B继承A，B会‘遗传’A的所有属性(数据属性和函数属性)，实现代码重用 # 猫类 抓老鼠 # 狗类 看门 # 动物 吃 喝 睡 class Animal: def eat(self): print('eating') def drink(self): print('drinking') def sleep(self): print('sleeping') class Cat(Animal): def catch_mouse(self): print('yeah') class Dog(Animal): def watch_door(self): print('wangwangwang') kitty = Cat() kitty.eat() snoopy = Dog() snoopy.eat() 派生 当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了 派生属性 ： 在自己的init方法里 使用父类的init方法 —— 指名道姓调用方法 派生方法 ： 在子类中增加父类没有的 只要子类有，就有子类的 只要想用父类，Animal.eat(snoopy) 父类名.父类的方法(子类对象) 2.7经典类中 #人 狗 相同属性的同时 还有一些不同的属性 class Animal: def __init__(self,aggressivity, life_value,name): self.name = name # 每一个角色都有自己的昵称; self.aggressivity = aggressivity # 每一个角色都有自己的攻击力; self.life_value = life_value # 每一个角色都有自己的生命值; def eat(self): self.life_value += 10 class Person(Animal): def __init__(self, name, aggressivity, life_value, money): Animal.__init__(self, name, aggressivity, life_value) self.money = money #派生属性：父类没有的属性 def attack(self,dog): dog.life_value -= self.aggressivity def get_weapon(self,weapon_obj): if self.money > weapon_obj.price: self.money -= weapon_obj.price # 金老板花钱买武器 self.weapon = weapon_obj # 金老板装备打狗棒 self.aggressivity += weapon_obj.aggr # 金老板的攻击力增加了 class Dog(Animal): def __init__(self, name, breed, aggressivity, life_value): Animal.__init__(self,aggressivity,life_value,name) self.breed = breed # 每一只狗都有自己的品种; #派生属性：父类没有的属性 def bite(self,people): # 派生方法 ：父类没有的方法 people.life_value -= self.aggressivity def eat(self): Animal.eat(self) print('dog is eating') snoopy = Dog('太白','京巴',250,500) print(snoopy.breed) print(snoopy.name) # Animal.eat(snoopy) snoopy.eat() print(snoopy.life_value) snoopy.eat() print(snoopy.life_value) 在新式类中 class Animal: def __init__(self,aggressivity, life_value,name): self.name = name # 每一个角色都有自己的昵称; self.aggressivity = aggressivity # 每一个角色都有自己的攻击力; self.life_value = life_value # 每一个角色都有自己的生命值; def eat(self): self.life_value += 10 class Person(Animal): def __init__(self, name, aggressivity, life_value, money): # Animal.__init__(self, name, aggressivity, life_value) super().__init__(name, aggressivity, life_value) #新式类 self.money = money #派生属性：父类没有的属性 def attack(self,dog): dog.life_value -= self.aggressivity def get_weapon(self,weapon_obj): if self.money > weapon_obj.price: self.money -= weapon_obj.price # 金老板花钱买武器 self.weapon = weapon_obj # 金老板装备打狗棒 self.aggressivity += weapon_obj.aggr # 金老板的攻击力增加了 class Dog(Animal): def __init__(self, name, breed, aggressivity, life_value): # Animal.__init__(self,aggressivity,life_value,name) # super(Dog,self).__init__(aggressivity,life_value,name) super().__init__(aggressivity,life_value,name) self.breed = breed # 每一只狗都有自己的品种; #派生属性：父类没有的属性 def bite(self,people): # 派生方法 ：父类没有的方法 people.life_value -= self.aggressivity def eat(self): # Animal.eat(self) super().eat() print('dog is eating') snoopy = Dog('太白','京巴',250,500) print(snoopy.breed) print(snoopy.name) snoopy.eat() print(snoopy.life_value) super(Dog,snoopy).eat() #Animal.eat(snoopy) print(snoopy.life_value) 用子类的对象，调用父类的方法： 如果子类中没有这个方法，直接就使用父类的 如果子类中有同名方法： 　　　　　　经典类 指名道姓 类名.方法名(子类对象) 类内外一致 　　　　　　新式类 super方法 super(子类名，子类对象).方法名() 类内可以省略super的参数 钻石继承 　　经典类和新式类的多继承问题，继承顺序问题 　　　　新式类：广度优先 　　　　经典类：深度优先 class F(object): pass def f(self): print('F') class E(F): pass def f(self): print('E') class D(F): pass # def f(self): # print('D') class B(D): pass # def f(self): # print('B') class C(E): pass def f(self): print('C') class A(B,C): pass # def f(self): # print('A') a = A() a.f() print(A.mro()) #新式类：查看继承顺序 # class A(object):pass #新式类 继承的作用 　　减少代码的重用 　　提高代码可读性 　　规范编程模式 多态 多态指的是一类事物有多种形态 动物有多种形态：人，狗，猪 class Animal:pass class Person(Animal): def attack(self): pass class Dog(Animal): def attack(self): pass def attack(obj): #多态 obj.attack() d = Dog() p = Person() attack(d) #d.attack() attack(p) #p.attack() 鸭子类型 　　Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子python程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。 　　例1：利用标准库中定义的各种‘与文件类似’的对象，尽管这些对象的工作方式像文件，但他们没有继承内置文件对象的方法 　　例2：序列类型有多种形态：字符串，列表，元组，但他们直接没有直接的继承关系 　　list tuple是一对鸭子类型 　　切片 ： 字符串 列表 元组 ​ +：字符串 列表 数字 #二者都像鸭子,二者看起来都像文件,因而就可以当文件一样去用 class TxtFile: def read(self): pass def write(self): pass class DiskFile: def read(self): pass def write(self): pass 抽象类与接口类 接口类 继承有两种用途： 　　　　1、继承基类的方法，并且做出自己的改变或者扩展（代码重用） 　　　　2、声明某个子类兼容于某基类，定义一个接口类Interface，接口类中定义了一些接口名（就是函数名）且并未实现接口的功能，子类继承接口类，并且实现接口中的功能 from abc import ABCMeta,abstractmethod class Fly_Animal(metaclass=ABCMeta): #规范 @abstractmethod def fly(self):pass class Swim_Animal(metaclass=ABCMeta): @abstractmethod def swim(self): pass class Walk_Animal(metaclass=ABCMeta): @abstractmethod def walk(self): pass class Frog(Walk_Animal,Swim_Animal): def walk(self): print('自己实现walk功能') def swim(self): pass class Swan(Walk_Animal,Swim_Animal,Fly_Animal): pass class Bird(Walk_Animal,Fly_Animal): pass 　　接口类： 　　　　是规范子类的一个模板，只要接口类中定义，就应该在子类中实现 　　　　接口类不能被实例化，只能被继承 　　　　支持多继承 class Payment(metaclass=ABCMeta): #模板，接口类 @abstractmethod #装饰接口类中方法的，加上这个装饰器，自动检测子类中的方法名 def pay(self,money):pass @abstractmethod def get(self):pass class Apple_Pay(Payment): def pay(self,money): print('您使用苹果支付支付了%s元'%money) class Ali_Pay(Payment): def pay(self, money): print('您使用支付宝支付了%s元' % money) class WeChat_Pay(Payment): def pay(self,money): print('您使用微信支付了%s元' % money) def pay(obj,money): return obj.pay(money) apple = Apple_Pay() ali = Ali_Pay() wechat = WeChat_Pay() pay(apple,100) #apple.pay(100) pay(wechat,200) 抽象类 什么是抽象类 ​ 　　与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化 为什么要有抽象类 ​ 　　如果说类是从一堆对象中抽取相同的内容而来的，那么抽象类就是从一堆类中抽取相同的内容而来的，内容包括数据属性和函数属性。 　　　 比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西。 ​ 　　从设计角度去看，如果类是从现实对象抽象而来的，那么抽象类就是基于类抽象而来的。 　 　　从实现角度来看，抽象类与普通类的不同之处在于：抽象类中有抽象方法，该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的 　　抽象类可以实现一些子类共有的功能和属性\\抽象类不鼓励多继承 　　　　文件操作 ：打开文件 关闭文件 写文件 读文件 　　　　硬盘操作：打开，关闭，写 读 　　　　进程文件：打开 关闭，读 写 　　　　python 没有接口的概念 　　　　只能借助抽象类的模块 来实现接口类 　　　　接口 —— java : 没有多继承 —— Interface 在python中实现抽象类　 from abc import ABCMeta,abstractmethod class Base(metaclass=ABCMeta): def __init__(self,filename): self.filename = filename @abstractmethod #抽象方法 def open(self): return 'file_handler' @abstractmethod def close(self):pass @abstractmethod def read(self):pass @abstractmethod def write(self):pass class File(Base): def open(self):pass def close(self):pass def read(self):pass def write(self):pass ​ 抽象类不能被实例化 　　这个抽象类可以规范子类必须实现抽象类中的抽象方法 名词 　　抽象：抽象即抽取类似或者说比较像的部分。是一个从具题到抽象的过程 　　 继承：子类继承了父类的方法和属性 　　 派生：子类在父类方法和属性的基础上产生了新的方法和属性 抽象类与接口类 　　1.多继承问题 　　在继承抽象类的过程中，我们应该尽量避免多继承； 　　而在继承接口的时候，我们反而鼓励你来多继承接口 　　2.方法的实现 　　在抽象类中，我们可以对一些抽象方法做出基础实现； 　　而在接口类中，任何方法都只是一种规范，具体的功能需要子类实现 封装 封装 ​ 隐藏对象的属性和实现细节，仅对外提供公共访问方式。 优点： ​ 1.将变化隔离 ​ 2.便于使用 ​ 3.提高复用性 ​ 4.提高安全性 封装原则 ​ 1.将不需要对外提供的内容都隐藏起来 ​ 2.把属性都隐藏，提供公共方法对其访问 私有变量和私有方法 　　在python中用双下划线开头的方式将属性隐藏起来（设置成私有的） 私有变量 class Dog: __role = 'dog' #私有的静态属性 def __discount(self): #私有的方法 print('in __func') def price(self): self.__discount() print(Dog.__dict__) print(Dog._Dog__role) 从类的外面不能直接调用，在类内的使用加上了一层密码：_类名 d = Dog() d.__func() 　　定义一个私有变量\\属性\\方法 ： __名字 　　在类的内部可以直接用 : __名字 　　在类的外部不能直接使用，如果一定要用，在私有方法之前加上：类名,变成 类名__名字 　　在类外的名字 通过dict就可以查看 私有方法 　　在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的 class A: def __func(self): print('__a_func') class B(A): def __init__(self): self.__func() b = B() 私有的静态属性、方法、对象属性 使用__名字的方式调用，保证在类内部可以调用，外部不行 私有的 不能被继承 当有一个名字，不想被外部使用也不想被子类继承，只想在内部使用的时候就定义私有的 封装与扩展性 封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑 class Room: def __init__(self,name,price,length,width): self.name = name self.price = price self.__length =length #私有的对象属性 self.__width = width def area(self): return self.__length*self.__width house = Room('小超超',1000000,2,1) print(house.area()) property属性 　　 property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值 class Person: def __init__(self,name,height,weight): self.name = name self.height = height self.__weight = weight @property def bmi(self): return self.__weight / (self.height ** 2) li = Person('李岩',1.75,85) print(li.bmi()) 为什么要用property 将一个类的函数定义成特性，对象再去使用的时候obj.name根本无法察觉自己的name是执行了一个函数然后计算出来的，这种特性的使用方式遵循了统一访问原则 面向对象的封装有三种方式: 【public】 这种其实就是不封装,是对外公开的 【protected】 这种封装方式对外不公开,但对朋友(friend)或者子类(形象的说法是“儿子”,但我不知道为什么大家 不说“女儿”,就像“parent”本来是“父母”的意思,但中文都是叫“父类”)公开 【private】 这种封装对谁都不公开 python并没有在语法上把它们三个内建到自己的class机制中，在C++里一般会将所有的数据都设置为私有的，然后提供set和get方法（接口）去设置和获取，在python中通过property方法可以实现 class Foo: def __init__(self,val): self.__NAME=val #将所有的数据属性都隐藏起来 @property def name(self): return self.__NAME #obj.name访问的是self.__NAME(这也是真实值的存放位置) @name.setter def name(self,value): if not isinstance(value,str): #在设定值之前进行类型检查 raise TypeError('%s must be str' %value) self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME @name.deleter def name(self): raise TypeError('Can not delete') f=Foo('egon') print(f.name) # f.name=10 #抛出异常'TypeError: 10 must be str' del f.name #抛出异常'TypeError: Can not delete' @property 把一个方法 伪装成一个属性zzzzzzzd ​ 1.属性的值 是这个方法的返回值 ​ 2.这个方法不能有参数了 圆形类 ： 面积 周长 from math import pi class Circle: def __init__(self,r): self.r = r @property def area(self): return self.r*self.r*pi @property def perimeter(self): return self.r*pi*2 c1 = Circle(5) print(c1.area) print(c1.perimeter) class Goods: __discount = 0.8 #静态属性 def __init__(self,name,price): self.__name = name self.__price = price #原价 @property def name(self): return self.__name @name.setter def name(self,new_name): self.__name = new_name @property def price(self): #折后价 return self.__price * Goods.__discount @price.setter def price(self,new_price): #修改原价 if type(new_price) is int: self.__price = new_price apple = Goods('苹果',10) apple.price = '10' #settrt print(apple.price) #property 　　封装 　　__私有+property 　　让对象的属性变得更安全了 　　获取到的对象的值可以进行一些加工 　　修改对象的值的同时可以进行一些验证 class Foo: @property def AAA(self): print('get的时候运行我啊') @AAA.setter def AAA(self,value): print('set的时候运行我啊') @AAA.deleter def AAA(self): print('delete的时候运行我啊') #只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter f1=Foo() print(f1.AAA) #property f1.AAA='aaa' #setter del f1.AAA #deleter ​ 一个静态属性property本质就是实现了get，set，delete三种方法 class Goods: __discount = 0.8 #静态属性 def __init__(self,name,price): self.__name = name self.__price = price #原价 @property def name(self): return self.__name @name.setter def name(self,new_name): self.__name = new_name @name.deleter def name(self): del self.__name @property def price(self): #折后价 return self.__price * Goods.__discount @price.setter def price(self,new_price): #修改原价 if type(new_price) is int: self.__price = new_price apple = Goods('苹果',10) # del apple.name # print(apple.name) classmethod 把一个方法变成一个类中的方法，这个方法就直接可以被类调用，不需要依托任何对象 　　定义一个类 　　类里面的方法 　　并没有用到self 当一个方法的操作只涉及静态属性的时候，就应该使用classmethod来装饰这个方法 class Goods: __discount = 0.8 @classmethod #类方法 def change_discount(cls,new_discount): cls.__discount = new_discount @classmethod def get_discount(cls): return cls.__discount # apple = Goods() Goods.change_discount(0.75) print(Goods.get_discount()) 类方法 调用：不需要实例化 直接用类名调用就好 定义：不用接受self参数，默认传cls，cls就代表当前方法所在的类 什么时候用类方法？ 需要使用静态变量且不需要和对象相关的任何操作的时候 静态方法 如果这个方法 既不需要操作静态变量 也不需要使用对象相关的操作， 　　　　　　 就使用静态方法 staticmethod 在完全面向对象的程序中，如果一个函数既和对象没有关系，也和类没有关系，那么就用staticmethod将这个函数变成一个静态方法 class A: @staticmethod def func(name): #静态方法 print(123) A.func('alex') 　　staticmethod是一个专门为面向对象编程提供的方法 　　它完全可以当做普通函数去用，只不过这个函数要通过类名.函数名调用 　　其他 传参 返回值 完全没有区别 绑定方法 和 非绑定方法 class A: @staticmethod def func1(name): #静态方法 print(123) @classmethod def func2(cls): # 静态方法 print(123) def func3(self):pass a = A() print(a.func1) #静态方法 print(a.func2) #类方法 ： 绑定到A类的func print(a.func3) #普通方法：绑定到A类对象的func 　　类里面，一共可以定义这三种方法： 　　普通方法 self 　　类方法 cls 　　静态方法 静态方法和类方法 都是直接可以使用类名调用 普通方法：对象调用 "},"Python/08-Object-Oriented Advanced.html":{"url":"Python/08-Object-Oriented Advanced.html","title":"Object-Oriented Advanced","keywords":"","body":"Object-Oriented Advanced isinstance和issubclass:jack_o_lantern: isinstance(obj,cls)检查obj是否是cls的对象 class Foo(object): pass obj = Foo() isinstance(obj, Foo) issubclass(sub,super)检查sub类是否是super类的派生类 class Foo(object): pass class Bar(Foo): pass issubclass(Bar, Foo) 反射:jack_o_lantern: 什么是反射 反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）这一概念的提出很快引发了计算机科学领域关于应用反射性的研究，它首先被程序语言的设计领域所采用，并在Lisp和面向对象方面取得了成绩 python面向对象中的反射：通过字符串的形式操作对象相关的属性，python中一切事物都是对象（都可以使用反射） 四个可以实现自省的函数，适用于类和对象（python一切皆对象，类本身也是一个对象） #hasattr def hasattr(*args, **kwargs): # real signature unknown \"\"\" Return whether the object has an attribute with the given name. This is done by calling getattr(obj, name) and catching AttributeError. \"\"\" pass #getattr def getattr(object, name, default=None): # known special case of getattr \"\"\" getattr(object, name[, default]) -> value Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y. When a default argument is given, it is returned when the attribute doesn't exist; without it, an exception is raised in that case. \"\"\" pass #setattr def setattr(x, y, v): # real signature unknown; restored from __doc__ \"\"\" Sets the named attribute on the given object to the specified value. setattr(x, 'y', v) is equivalent to ``x.y = v'' \"\"\" pass #delattr def delattr(x, y): # real signature unknown; restored from __doc__ \"\"\" Deletes the named attribute from the given object. delattr(x, 'y') is equivalent to ``del x.y'' \"\"\" pass #四个方法的使用 class Foo: f = '类的静态变量' def __init__(self,name,age): self.name=name self.age=age def say_hi(self): print('hi,%s'%self.name) obj=Foo('egon',73) #检测是否含有某属性 print(hasattr(obj,'name')) print(hasattr(obj,'say_hi')) #获取属性 n=getattr(obj,'name') print(n) func=getattr(obj,'say_hi') func() print(getattr(obj,'aaaaaaaa','不存在啊')) #报错 #设置属性 setattr(obj,'sb',True) setattr(obj,'show_name',lambda self:self.name+'sb') print(obj.__dict__) print(obj.show_name(obj)) #删除属性 delattr(obj,'age') delattr(obj,'show_name') delattr(obj,'show_name111')#不存在,则报错 print(obj.__dict__) #类本身也是一个对象 class Foo(object): staticField = \"old boy\" def __init__(self): self.name = 'wupeiqi' def func(self): return 'func' @staticmethod def bar(): return 'bar' print getattr(Foo, 'staticField') print getattr(Foo, 'func') print getattr(Foo, 'bar') #反射当前模块成员 import sys def s1(): print 's1' def s2(): print 's2' this_module = sys.modules[__name__] hasattr(this_module, 's1') getattr(this_module, 's2') 导入其他模块，利用反射查找该模块是否存在某个方法 def test(): print('from the test') \"\"\" 程序目录： module_test.py index.py 当前文件： index.py \"\"\" import module_test as obj #obj.test() print(hasattr(obj,'test')) getattr(obj,'test')() str和repr:jack_o_lantern: 改变对象的字符串显示str，repr 自定制格式化字符串format format_dict={ 'nat':'{obj.name}-{obj.addr}-{obj.type}',#学校名-学校地址-学校类型 'tna':'{obj.type}:{obj.name}:{obj.addr}',#学校类型:学校名:学校地址 'tan':'{obj.type}/{obj.addr}/{obj.name}',#学校类型/学校地址/学校名 } class School: def __init__(self,name,addr,type): self.name=name self.addr=addr self.type=type def __repr__(self): return 'School(%s,%s)' %(self.name,self.addr) def __str__(self): return '(%s,%s)' %(self.name,self.addr) def __format__(self, format_spec): # if format_spec if not format_spec or format_spec not in format_dict: format_spec='nat' fmt=format_dict[format_spec] return fmt.format(obj=self) s1=School('oldboy1','北京','私立') print('from repr: ',repr(s1)) print('from str: ',str(s1)) print(s1) ''' str函数或者print函数--->obj.__str__() repr或者交互式解释器--->obj.__repr__() 如果__str__没有被定义,那么就会使用__repr__来代替输出 注意:这俩方法的返回值必须是字符串,否则抛出异常 ''' print(format(s1,'nat')) print(format(s1,'tna')) print(format(s1,'tan')) print(format(s1,'asfdasdffd')) #%s和%r class B: def __str__(self): return 'str : class B' def __repr__(self): return 'repr : class B' b=B() print('%s'%b) print('%r'%b) del:jack_o_lantern: 析构方法，当对象在内存中被释放时，自动触发执行 析构方法无需定义，python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给python解释器来执行，析构函数的调用时由解释器在进行垃圾回收是自动触发执行的 # class A: # def __del__(self): # 析构函数: 在删除一个对象之前进行一些收尾工作 # self.f.close() # a = A() # a.f = open() # 打开文件 第一 在操作系统中打开了一个文件 拿到了文件操作符存在了内存中 # a.f 拿到了文件操作符消失在了内存中 # del a # del 既执行了这个方法，又删除了变量 item系列:jack_o_lantern: getitem_setitem\\delitem_ class Foo: def __init__(self,name): self.name=name def __getitem__(self, item): print(self.__dict__[item]) def __setitem__(self, key, value): self.__dict__[key]=value def __delitem__(self, key): print('del obj[key]时,我执行') self.__dict__.pop(key) def __delattr__(self, item): print('del obj.key时,我执行') self.__dict__.pop(item) f1=Foo('sb') f1['age']=18 f1['age1']=19 del f1.age1 del f1['age'] f1['name']='alex' print(f1.__dict__) new:jack_o_lantern: 构造方法：创建一个对象 class A: def __init__(self): self.x = 1 print('in init function') def __new__(cls, *args, **kwargs): print('in new function') return object.__new__(A, *args, **kwargs) # a1 = A() # a2 = A() # a3 = A() # print(a1) # print(a2) # print(a3) # print(a.x) class A: def __init__(self): self.x = 1 print('in init function') def __new__(cls, *args, **kwargs): print('in new function') return object.__new__(A, *args, **kwargs) a = A() print(a.x) #单例模式 class Singleton: def __new__(cls, *args, **kw): if not hasattr(cls, '_instance'): cls._instance = object.__new__(cls, *args, **kw) return cls._instance one = Singleton() two = Singleton() two.a = 3 print(one.a) # 3 # one和two完全相同,可以用id(), ==, is检测 print(id(one)) # 29097904 print(id(two)) # 29097904 print(one == two) # True print(one is two) call:jack_o_lantern: 对象后面加括号，触发执行 析构方法的执行时由创建对象触发的，即：对象=类名() ，而对于call方法的执行时由对象后加括号触发的，即：对象() 或者 类()() class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__') obj = Foo() # 执行 __init__ obj() # 执行 __call__ class A: def __init__(self,name): self.name = name def __call__(self): ''' 打印这个对象中的所有属性 :return: ''' for k in self.__dict__: print(k,self.__dict__[k]) a = A('alex')() len:jack_o_lantern: class A: def __init__(self): self.a = 1 self.b = 2 def __len__(self): return len(self.__dict__) a = A() print(len(a)) hash:jack_o_lantern: class A: def __init__(self): self.a = 1 self.b = 2 def __hash__(self): return hash(str(self.a)+str(self.b)) a = A() print(hash(a)) eq:jack_o_lantern: class A: def __init__(self): self.a = 1 self.b = 2 def __eq__(self,obj): if self.a == obj.a and self.b == obj.b: return True a = A() b = A() print(a == b) #Card Games class FranchDeck: ranks = [str(n) for n in range(2,11)] + list('JQKA') suits = ['红心','方板','梅花','黑桃'] def __init__(self): self._cards = [Card(rank,suit) for rank in FranchDeck.ranks for suit in FranchDeck.suits] def __len__(self): return len(self._cards) def __getitem__(self, item): return self._cards[item] deck = FranchDeck() print(deck[0]) from random import choice print(choice(deck)) print(choice(deck)) #Card Games2 class FranchDeck: ranks = [str(n) for n in range(2,11)] + list('JQKA') suits = ['红心','方板','梅花','黑桃'] def __init__(self): self._cards = [Card(rank,suit) for rank in FranchDeck.ranks for suit in FranchDeck.suits] def __len__(self): return len(self._cards) def __getitem__(self, item): return self._cards[item] def __setitem__(self, key, value): self._cards[key] = value deck = FranchDeck() print(deck[0]) from random import choice print(choice(deck)) print(choice(deck)) from random import shuffle shuffle(deck) print(deck[:5]) "},"Python/README .html":{"url":"Python/README .html","title":"README ","keywords":"","body":"The history of Python Origin :jack_o_lantern: Python的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范罗苏姆（中文名字：龟叔）为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。 （龟叔：2005年加入谷歌至2012年，2013年加入Dropbox直到现在，依然掌握着Python发展的核心方向，被称为仁慈的独裁者） 1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新 的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的 核心数据类型，以及模块为基础的拓展系统。 Granddaddy of Python web frameworks, Zope 1 was released in 1999 Python 1.0 - January 1994 增加了 lambda, map, filter and reduce Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础 Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django 诞生 Python 2.5 - September 19, 2006 Python 2.6 - October 1, 2008 Python 2.7 - July 3, 2010 In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible Python 3.0 - December 3, 2008 Python 3.1 - June 27, 2009 Python 3.2 - February 20, 2011 Python 3.3 - September 29, 2012 Python 3.4 - March 16, 2014 Python 3.5 - September 13, 2015 Python 3.6 - December 16,2016 Python崇尚优美、清晰、简单，是一门优秀并广泛应用的语言，Python可以应用于众多领域，如：数据分析、组件集成、网络服务、图像处理、数值计算和科学计算等众 多领域。目前业内几乎所有大中型互联网企业都在使用Python，如：Youtube、Dropbox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo!、Facebook、 NASA、百度、腾讯、汽车之家、美团等。 目前Python主要应用领域： 云计算: 云计算最火的语言， 典型应用OpenStack WEB开发: 众多优秀的WEB框架，众多大型网站均为Python开发，Youtube, Dropbox, 豆瓣。。。， 典型WEB框架有Django 科学运算、人工智能: 典型库NumPy, SciPy, Matplotlib, Enthought librarys,pandas 系统运维: 运维人员必备语言 金融：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。原因：作为动态语言的Python，语言结构清晰简单，库丰富， 成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c,c++,java,尤其擅长策略回测 图形GUI: PyQT, WxPython,TkInter Python在一些公司的应用： 谷歌：Google App Engine 、code.google.com 、Google earth 、谷歌爬虫、Google广告等项目都在大量使用Python开发 CIA: 美国中情局网站就是用Python开发的 NASA: 美国航天局(NASA)大量使用Python进行数据分析和运算 YouTube:世界上最大的视频网站YouTube就是用Python开发的 Dropbox:美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载 Instagram:美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发 Facebook:大量的基础库均通过Python实现的 Redhat: 世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的 豆瓣: 公司几乎所有的业务均是通过Python开发的 知乎: 国内最大的问答社区，通过Python开发(国外Quora) 春雨医生：国内知名的在线医疗网站是用Python开发的 除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。 "},"Socket/":{"url":"Socket/","title":"Socket","keywords":"","body":"Welcome to Poppy's blog! Introduction "},"Socket/01-Socket Introduce.html":{"url":"Socket/01-Socket Introduce.html","title":"Socket Introduce","keywords":"","body":"Socket 操作系统基础:jack_o_lantern: 操作系统(Operating System , 简称OS)：是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在计算机上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行 操作系统是用户和计算机的接口，同时也是计算机硬件和其它软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，改善人机界面，为其它应用软件提供支持，让计算机系统所有资源最大限度地发挥作用，提供各种形式的用户界面，使用户有一个好的工作环境，为其它软件的开发提供必要的服务和相应的接口等。实际上，用户是不用接触操作系统的，操作系统管理着计算机硬件资源，同时按照应用程序的资源请求，分配资源，如：划分CPU时间，内存空间的开辟等 ps：计算机(硬件) - OS - 应用软件 网络通信原理:jack_o_lantern: 互联网的本质就是一系列的网络协议 OSI七层协议 基本介绍 ​ ISO国际标准组织所定义的开放系统互连七层模型的定义和各层功能。它是网络技术入门者的敲门砖，也是分析、评判各种网络技术的依据—从此网络不再神秘，它也是有理可依，有据可循的。 　　建立七层模型主要是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来；也使网络的不同功能模块分担起不同的职责。 　　网络发展中一个重要里程碑便是ISO（Internet Standard Organization，国际标准组织对OSI(Open System Interconnect)，开放系统互连）七层网络模型的定义。它不但成为以前的和后续的各种网络技术评判、分析的依据，也成为网络协议设计和统一的参考模型。 　　建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。网络七层的划分也是为了使网络的不同功能模块（不同层次）分担起不同的职责，从而带来如下好处： 　　● 减轻问题的复杂程度，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错 　　● 在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则相对独立，一种高层协议可放在多种低层协议上运行 　　● 能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手术 　　● 便于研究和教学 OSI各层介绍 ​ OSI 七层模型称为开放式系统互联参考模型 OSI 七层模型是一种框架性的设计方法 　　OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能使就是帮助不同类型的主机实现数据传输 　 osi七层模型　 ​ 物理层 ：OSI模型的最低层或第一层，该层包括物理连网媒介，如电缆连线连接器。物理层的协议产生并检测电压以便发送和接收携带数据的信号。在你的桌面PC上插入网络接口卡，你就建立了计算机连网的基础。换言之，你提供了一个物理层。尽管物理层不提供纠错服务，但它能够设[数据传输速率并监测数据出错率。网络物理问题，如电线断开，将影响物理层。 　　用户要传递信息就要利用一些物理媒体，如双绞线、同轴电缆等，但具体的物理媒体并不在OSI的7层之内，有人把物理媒体当做第0层，物理层的任务就是为它的上一层提供一个物理连接，以及它们的机械、电气、功能和过程特性。如规定使用电缆和接头的类型、传送信号的电压等。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理，单位是比特。 　　数据链路层：OSI模型的第二层，它控制网络层与物理层之间的通信。它的主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的网络地址以及纠错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。 如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。 　　数据链路层的功能独立于网络和它的节点和所采用的物理层类型，它也不关心是否正在运行 Word 、Excel 或使用Internet 。有一些连接设备，如交换机，由于它们要对帧解码并使用帧信息将数据发送到正确的接收方，所以它们是工作在数据链路层的。 　　网络层： OSI模型的第三层，其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。 　　网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点Ａ 到另一个网络中节点Ｂ 的最佳路径。由于网络层处理路由，而路由器因为即连接网络各段，并智能指导数据传送，属于网络层。在网络中，“路由”是基于编址方案、使用模式以及可达性来指引数据的发送。 　　传输层：OSI模型中最重要的一层。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1500字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。 　　工作在传输层的一种服务是 TCP/IP协议套中的TCP（传输控制协议），另一项传输层服务是IPX /SPX协议集的SPX（序列包交换）。 　　会话层： 负责在网络中的两节点之间建立和维持通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对 话，决定通信是否被中断以及通信中断时决定从何处重新发送。 　　你可能常常听到有人把会话层称作网络通信的“交通警察”。当通过拨号向你的 ISP（因特网服务提供商）请求连接到因特网时ISP服务器上的会话层向你与你的PC客户机上的会话层进行协商连接。若你的电话线偶然从墙上插孔脱落时，你终端机上的会话层将检测到连接中断并重新发起连接。会话层通过决定节点通信的优先级和通信时间的长短来设置通信期限 　　表示层： 应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 　　表示层管理数据的解密与加密，如系统口令的处理。例如：在 Internet上查询你银行账户，使用的即是一种安全连接。你的账户数据在发送前被加密，在网络的另一端，表示层将对接收到的数据解密。除此之外，表示层协议还对图片和文件格式信息进行解码和编码。 　　应用层： 负责对软件提供接口以使程序能使用网络服务。术语“应用层”并不是指运行在网络上的某个特别应用程序 ，应用层提供的服务包括文件传输、文件管理以及电子邮件的信息处理。 socket简介:jack_o_lantern: ​ Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，我们经常把socket翻译为套接字，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 ​ 所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。 套接字发展史及分类:jack_o_lantern: ​ 套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 基于文件类型的套接字家族 套接字家族的名字：AF_UNIX unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信 基于网络类型的套接字家族 套接字家族的名字：AF_INET (还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET) 套接字工作流程:jack_o_lantern: ​ 一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理 import socket socket.socket(socket_family,socket_type,protocal=0) socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 0 获取tcp/ip套接字 tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 获取udp/ip套接字 udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 由于 socket 模块中有太多的属性。我们在这里破例使用了'from module import *'语句。使用 'from socket import *',我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。 例如tcpSock = socket(AF_INET, SOCK_STREAM) 服务端套接字函数 s.bind() 绑定(主机,端口号)到套接字 s.listen() 开始TCP监听 s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来 客户端套接字函数 s.connect() 主动初始化TCP服务器连接 s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常 公共用途的套接字函数 s.recv() 接收TCP数据 s.send() 发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完) s.sendall() 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完) s.recvfrom() 接收UDP数据 s.sendto() 发送UDP数据 s.getpeername() 连接到当前套接字的远端的地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回指定套接字的参数 s.setsockopt() 设置指定套接字的参数 s.close() 关闭套接字 面向锁的套接字方法 s.setblocking() 设置套接字的阻塞与非阻塞模式 s.settimeout() 设置阻塞套接字操作的超时时间 s.gettimeout() 得到阻塞套接字操作的超时时间 面向文件的套接字的函数 s.fileno() 套接字的文件描述符 s.makefile() 创建一个与该套接字相关的文件 基于TCP的套接字 tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端 TCP是可靠传输 服务端 import socket phone=socket.socket() phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) phone.bind(('127.0.0.1',8082)) phone.listen(5) while True: conn,addr=phone.accept() print(addr) while True: try: data=conn.recv(1024) conn.send(data.upper()) except ConnectionResetError: break conn.close() phone.close() 客户端 import socket phone = socket.socket() phone.connect(('127.0.0.1',8080)) while True: msg = input('>>:').strip() phone.send(msg.encode('utf-8')) data = phone.recv(1024) print(data.decode('utf-8')) phone.close() 基于UDP的套接字 udp是无链接的，先启动哪一端都不会报错 服务端 from socket import * server = socket(AF_INET,SOCK_DGRAM) server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) server.bind(('127.0.0.1',8080)) while True: data,client_addr = server.recvfrom(1024) print('client\\'s data:',data) server.sendto(data.upper(),client_addr) 客户端 from socket import * client = socket(AF_INET,SOCK_DGRAM) while True: msg = input('>>:').strip() client.sendto(msg.encode('utf-8'),('127.0.0.1',8080)) data,server_addr = client.recvfrom(1024) print(data.decode('utf-8')) ps： tcp是可靠传输，udp是不可靠传输 tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的 而udp发送数据，对端是不会返回确认信息的，因此不可靠 send(字节流)和recv(1024)及sendall recv里指定的1024意思是从缓存里一次拿出1024个字节的数据 send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失 "},"Web/":{"url":"Web/","title":"Web","keywords":"","body":"Welcome to Poppy's blog! Introduction "},"Web/01-HTML.html":{"url":"Web/01-HTML.html","title":"HTML","keywords":"","body":"HTML初识:jack_o_lantern: web服务本质 web服务的本质就是一个socket 浏览器发请求 --> HTTP协议 --> 服务端接收请求 --> 服务端返回响应 --> 服务端把HTML文件内容发给浏览器 --> 浏览器渲染页面 import socket def main(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind(('localhost',8080)) sock.listen(5) while True: print(\"server is working.....\") conn, address = sock.accept() request = conn.recv(1024) conn.sendall(bytes(\"HTTP/1.1 201 OK\\r\\n\\r\\nHello World\",\"utf8\")) conn.close() if __name__ == '__main__': main() 超文本标记语言(Hypertext Markup Language——HTML)是一种用于创建网页的标记语言。 本质上是浏览器可识别的规则，我们按照规则写网页，浏览器根据规则渲染我们的网页。对于不同的浏览器，对同一个标签可能会有不同的解释。(兼容性问题) HTML使用标签来描述网页，它不是一种编程语言。 HTML文档结构 css样式优先级 声明为HTML5文档。 \\、\\是文档的开始标记和结束的标记。是HTML页面的根元素，在它们之间是文档的头部（head）和主体（body）。 \\、\\定义了HTML文档的开头部分。它们之间的内容不会在浏览器的文档窗口显示。包含了文档的元（meta）数据。 \\、\\定义了网页标题，在浏览器标题栏显示。 \\、\\之间的文本是可见的网页主体内容。 注意：对于中文网页需要使用 \\ 声明编码，否则会出现乱码。有些浏览器会设置 GBK 为默认编码，则你需要设置为 \\。 HTML标签格式 HTML标签是由尖括号包围的关键字，如\\, \\等 HTML标签通常是成对出现的，比如：\\和\\，第一个标签是开始，第二个标签是结束。结束标签会有斜线。 也有一部分标签是单独呈现的，比如：\\、\\、\\等。 标签里面可以有若干属性，也可以不带属性。 标签的语法： 内容部分 几个很重要的属性： id：定义标签的唯一ID，HTML文档树中唯一 class：为html元素定义一个或多个类名（classname）(CSS样式类名) style：规定元素的行内样式（CSS样式） HTML注释 HTML常用标签:jack_o_lantern: 标签 声明位于文档中的最前面的位置， 声明不是 HTML 标签，处于\\ 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 作用：声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。 document.compatMode： BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat head内常用标签 标签 意义 \\\\ 定义网页标题 \\\\ 定义内部样式表 \\\\ 定义JS代码或引入外部JS文件 \\ 引入外部样式表文件 \\ 定义网页原信息 Meta标签介绍： \\元素可提供有关页面的原信息（mata-information）,针对搜索引擎和更新频度的描述和关键词。 \\标签位于文档的头部，不包含任何内容。 \\提供的信息是用户不可见的。 meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 1.http-equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 2.name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 body常用标签 基本标签（块级标签和内联标签） 加粗 斜体 下划线 删除 段落标签 标题1 标题2 标题3 标题4 标题5 标题6 特殊字符 内容 对应代码 空格   > > & & ¥ ¥ 版权 © 注册 ® div标签和span标签 div标签用来定义一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。 span标签用来定义内联(行内)元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。 块级元素与行内元素的区别： 所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。 这两个元素是专门为定义CSS样式而生的。 注意： 关于标签嵌套：通常块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。 p标签不能包含块级标签。 img标签 a标签 超链接标签，所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。 什么是URL？ URL是统一资源定位器(Uniform Resource Locator)的缩写，也被称为网页地址，是因特网上标准的资源的地址。 URL举例 http://www.sohu.com/stu/intro.html http://222.172.123.33/stu/intro.html URL地址由4部分组成 第1部分：为协议：http://、ftp://等 第2部分：为站点地址：可以是域名或IP地址 第3部分：为页面在站点中的目录：stu 第4部分：为页面名称，例如 index.html 各部分之间用“/”符号隔开。 点击 href属性指定目标网页地址。该地址可以有几种类型： 绝对URL - 指向另一个站点（比如 href=\"http://www.jd.com\"） 相对URL - 指当前站点中确切的路径（href=\"index.htm\"） 锚URL - 指向页面中的锚（href=\"#top\"） target： _blank表示在新标签页中打开目标网页 _self表示在当前标签页中打开目标网页 列表 无序列表 第一项 第二项 type属性： disc（实心圆点，默认值） circle（空心圆圈） square（实心方块） none（无样式） 有序列表 第一项 第二项 type属性： 1 数字列表，默认值 A 大写字母 a 小写字母 Ⅰ大写罗马 ⅰ小写罗马 标题列表 标题1 内容1 标题2 内容1 内容2 表格 表格是一个二维数据空间，一个表格由若干行组成，一个行又有若干单元格组成，单元格里可以包含文字、列表、图案、表单、数字符号、预置文本和其它的表格等内容。 表格最重要的目的是显示表格类数据。表格类数据是指最适合组织为表格格式（即按行和列组织）的数据。 表格的基本结构 序号 姓名 爱好 1 ali ！！！ 2 Timo 种蘑菇 属性: border: 表格边框. cellpadding: 内边距 cellspacing: 外边距. width: 像素 百分比.（最好通过css来设置长宽） rowspan: 单元格竖跨多少行 colspan: 单元格横跨多少列（即合并单元格） form表单 功能： 表单用于向服务器传输数据，从而实现用户与Web服务器的交互 表单能够包含input系列标签，比如文本字段、复选框、单选框、提交按钮等等。 表单还可以包含textarea、select、fieldset和 label标签。 表单属性 属性 描述 accept-charset 规定在被提交表单中使用的字符集（默认：页面字符集）。 action 规定向何处提交表单的地址（URL）（提交页面）。 autocomplete 规定浏览器应该自动完成表单（默认：开启）。 enctype 规定被提交数据的编码（默认：url-encoded）。 method 规定在提交表单时所用的 HTTP 方法（默认：GET）。 name 规定识别表单的名称（对于 DOM 使用：document.forms.name）。 novalidate 规定浏览器不验证表单。 target 规定 action 属性中地址的目标（默认：_self）。 表单元素 基本概念： HTML表单是HTML元素中较为复杂的部分，表单往往和脚本、动态页面、数据处理等功能相结合，因此它是制作动态网站很重要的内容。 表单一般用来收集用户的输入信息 表单工作原理： 访问者在浏览有表单的网页时，可填写必需的信息，然后按某个按钮提交。这些信息通过Internet传送到服务器上。 服务器上专门的程序对这些数据进行处理，如果有错误会返回错误信息，并要求纠正错误。当数据完整无误后，服务器反馈一个输入完成的信息。 input 元素会根据不同的 type 属性，变化为多种形态。 type属性值 表现形式 对应代码 text 单行输入文本 password 密码输入框 \\ date 日期输入框 \\ checkbox 复选框 \\ radio 单选框 \\ submit 提交按钮 \\ reset 重置按钮 \\ button 普通按钮 \\ hidden 隐藏输入框 \\ file 文本选择框 \\ 属性说明: name：表单提交时的“键”，注意和id的区别 value：表单提交时对应项的值 type=\"button\", \"reset\", \"submit\"时，为按钮上显示的文本年内容 type=\"text\",\"password\",\"hidden\"时，为输入框的初始值 type=\"checkbox\", \"radio\", \"file\"，为输入相关联的值 checked：radio和checkbox默认被选中的项 readonly：text和password设置只读 disabled：所有input均适用 select标签 北京 上海 广州 深圳 属性说明： multiple：布尔属性，设置后为多选，否则默认单选 disabled：禁用 selected：默认选中该项 value：定义提交时的选项值 label标签 定义：\\ 标签为 input 元素定义标注（标记）。 说明： label 元素不会向用户呈现任何特殊效果。 \\ 标签的 for 属性值应当与相关元素的 id 属性值相同。 用户名 textarea多行文本 默认内容 属性说明： name：名称 rows：行数 cols：列数 disabled：禁用 fieldset标签 登录吧 "},"Web/02-CSS.html":{"url":"Web/02-CSS.html","title":"CSS","keywords":"","body":"CSS介绍:jack_o_lantern: CSS(Cascading Style Sheet，层叠样式表)定义如何显示HTML元素。 当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化（渲染）。 CSS语法:jack_o_lantern: 每个CSS样式由两个组成部分：选择器和声明。声明又包括属性和属性值。每个声明之后用分号结束。 CSS注释 /*这是注释*/ 引入方式:jack_o_lantern: 行内样式 行内式是在标记的style属性中设定CSS样式。不推荐大规模使用。 Hello world. 内部样式 嵌入式是将CSS样式集中写在网页的\\\\标签对的\\\\标签对中 Title p{ background-color: #eee; } 外部样式 链接式 将css写在一个单独的文件中，然后在HTML页面进行引入即可。推荐使用此方式。 导入式 导入式使用CSS规则引入外部CSS文件，\\标记也是写在\\标记中 @import\"mystyle.css\"; #此处要注意.css文件的路径 注意： ​ 导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。 CSS选择器:jack_o_lantern: 基本选择器 注意： ​ 样式类名不要用数字开头(有的浏览器不认识)。 ​ 标签中的class属性如果有多个，要用空格分隔。 组合选择器 后代选择器 /*li内部的a标签设置字体颜色*/ li a { color: green; } 子元素选择器 /*选择所有父级是 元素的 元素*/ div>p { font-family: \"Arial Black\", arial-black, cursive; } 毗邻选择器 /*选择所有紧接着元素之后的元素*/ div+p { margin: 5px; } 兄弟选择器 /*i1后面所有的兄弟p标签*/ #i1~p { border: 2px solid royalblue; } 关于标签嵌套： ​ 一般，块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。需要注意的是，p标签不能包含块级标签。 属性选择器 #常用属性选择器 /*用于选取带有指定属性的元素。*/ p[title] { color: red; } /*用于选取带有指定属性和值的元素。*/ p[title=\"213\"] { color: green; } #不常用属性选择器 /*找到所有title属性以hello开头的元素*/ [title^=\"hello\"] { color: red; } /*找到所有title属性以hello结尾的元素*/ [title$=\"hello\"] { color: yellow; } /*找到所有title属性中包含（字符串包含）hello的元素*/ [title*=\"hello\"] { color: red; } /*找到所有title属性(有多个值或值以空格分割)中有一个值为hello的元素：*/ [title~=\"hello\"] { color: green; } 伪类选择器 伪类指的是标签的不同状态 伪类选择器格式: 标签:伪类名称{ css代码; } anchor伪类：专用于控制链接的显示效果 a标签 ==> 点过状态 没有点过的状态 鼠标悬浮状态 激活状态 a:link（没有接触过的链接）,用于定义了链接的常规状态。 a:hover（鼠标放在链接上的状态）,用于产生视觉效果。 a:visited（访问过的链接）,用于阅读文章，能清楚的判断已经访问过的链接。 a:active（在链接上按下鼠标时的状态）,用于表现鼠标按下时的链接状 /* 未访问的链接 */ a:link {color: #FF0000} /* 已访问的链接 */ a:visited {color: #00FF00} /* 鼠标移动到链接上 */ a:hover {color: #FF00FF} /* 选定的链接 */ a:active {color: #0000FF} /*input输入框获取焦点时样式*/ input:focus { outline: none; background-color: #eee; } 伪元素选择器 first-letter 常用的给首字母设置特殊样式 p:first-letter { font-size: 48px; color: red; } before /*在每个元素之前插入内容*/ p:before { content:\"*\"; color:red; } after /*在每个元素之后插入内容*/ p:after { content:\"[?]\"; color:blue; } before和after多用于清除浮动。 分组和嵌套 分组 当多个元素的样式相同的时候，我们没有必要重复地为每个元素都设置样式，我们可以通过在多个选择器之间使用逗号分隔的分组选择器来统一设置元素样式。 div, p { color: red; } 上面代码为div标签和p标签统一设置字体为红色。 通常，我们会分两行来写，更清晰 div, p { color: red; } 嵌套 多种选择器可以混合起来使用，比如：.c1类内部所有p标签设置字体颜色为红色。 .c1 p { color: red; } 选择器的优先级:jack_o_lantern: CSS继承 继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个body定义了的字体颜色值也会应用到段落的文本中。 body { color: red; } hello world！ 这段文字都继承了由body {color:red;}样式定义的颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。 我们只要给对应的标签设置字体颜色就可覆盖掉它继承的样式。由此可见：任何显示申明的规则都可以覆盖其继承样式。　 p { color: green; } 此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。 div{ border:1px solid #222 } hello world CSS的优先级 所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。 样式表中的特殊性描述了不同规则的相对权重，它的基本规则是： 按这些规则将数字符串逐位相加，就得到最终的权重，然后在比较取舍时按照从左到右的顺序逐位比较。 1、文内的样式优先级为1,0,0,0，所以始终高于外部定义。 2、有!important声明的规则高于一切。 3、如果!important声明冲突，则比较优先权。 4、如果优先权一样，则按照在源码中出现的顺序决定，后来者居上。 5、由继承而得到的样式没有specificity的计算，它低于一切其它规则(比如全局选择符*定义的规则)。 虽然通过添加 !important方式可以强制让样式生效，但并不推荐使用。因为如果过多的使用!important会使样式文件混乱不易维护。 CSS属性操作:jack_o_lantern: 文本属性 文字字体 font-family可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。浏览器会使用它可识别的第一个值。 body { font-family: \"Microsoft Yahei\", \"微软雅黑\", \"Arial\", sans-serif } 字体大小 p { font-size: 14px; } 如果设置成inherit表示继承父元素的字体大小值。 字重 font-weight用来设置字体的字重（粗细）。 值 描述 normal 默认值，标准粗细 bold 粗体 bolder 更粗 lighter 更细 100~900 设置具体粗细，400等同于normal，而700等同于bold inherit 继承父元素字体的粗细值 文本颜色 颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 还有rgba(255,0,0,0.3)，第四个值为alpha, 指定了色彩的透明度/不透明度，它的范围为0.0到1.0之间。 文字装饰 text-decoration 属性用来给文字添加特殊效果。 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 inherit 继承父元素的text-decoration属性的值。 常用的为去掉a标签默认的自划线 a { text-decoration: none; } 水平对齐方式 text-align 属性规定元素中的文本的水平对齐方式。 left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 首行缩进 将段落的第一行缩进 32像素 p { text-indent: 32px; } 文本其他属性 line-height: 200px; 文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比 vertical-align:－4px 设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效 font-style: oblique 斜体 letter-spacing: 10px; 字母间距 word-spacing: 20px; 单词间距 text-transform: capitalize/uppercase/lowercase ; 文本转换，用于所有字句变成大写或小写字母，或每个单词的首字母大写 背景属性 /*背景颜色*/ background-color: red; /*背景图片*/ background-image: url('1.jpg'); /* 背景重复 repeat(默认):背景图片平铺排满整个网页 repeat-x：背景图片只在水平方向上平铺 repeat-y：背景图片只在垂直方向上平铺 no-repeat：背景图片不平铺 */ background-repeat: no-repeat; /*背景位置*/ background-position: right top（20px 20px）; 支持简写 background:#ffffff url('1.png') no-repeat right top; 使用背景图片的一个常见案例就是很多网站会把很多小图标放在一张图片上，然后根据位置去显示图片。减少频繁的图片请求。 滚动背景图 * { margin: 0; } .box { width: 100%; height: 500px; background: url(\"https:图片地址自定义\") no-repeat center center; background-attachment: fixed; } .d1 { height: 500px; background-color: tomato; } .d2 { height: 500px; background-color: steelblue; } .d3 { height: 500px; background-color: mediumorchid; } 边框属性 属性介绍 border-width border-style (required) border-color #i1 { border-width: 2px; border-style: solid; border-color: red; } 通常使用简写方式 #i1 { border: 2px solid red; } 边框样式 值 描述 none 无边框。 dotted 点状虚线边框。 dashed 矩形虚线边框。 solid 实线边框。 除了可以统一设置边框外还可以单独为某一个边框设置样式 #i1 { border-top-style:dotted; border-top-color: red; border-right-style:solid; border-bottom-style:dotted; border-left-style:none; } border-radius 用这个属性能实现圆角边框的效果。 将border-radius设置为长或高的一半即可得到一个圆形。 #圆形头像 圆形头像 * { margin: 0; padding: 0; background-color: #eeeeee; } .header-img { width: 150px; height: 150px; border: 3px solid white; border-radius: 100%; overflow: hidden; } .header-img>img { max-width: 100%; } display属性 用于控制HTML元素的显示效果。 值 意义 display:\"none\" HTML文档中元素存在，但是在浏览器中不显示。一般用于配合JavaScript代码使用。 display:\"block\" 内联标签设置为块级标签，默认占满整个页面宽度，如果设置了指定宽度，则会用margin填充剩下的部分。一个内联元素设置为display:block是不允许有它内部的嵌套块元素。 display:\"inline\" 按行内元素显示，此时再设置元素的width、height、margin-top、margin-bottom和float属性都不会有什么影响。 display:\"inline-block\" 使元素同时具有行内元素和块级元素的特点。 display:\"none\"与visibility:hidden的区别 visibility:hidden: 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display:none: 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 display:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决 #outer{ border: 3px dashed; word-spacing: -5px; } CSS盒子模型:jack_o_lantern: margin: 用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。 padding: 用于控制内容与边框之间的距离； Border(边框): 围绕在内边距和内容外的边框。 Content(内容): 盒子的内容，显示文本和图像。 margin外边距 .margin-test { margin-top:5px; margin-right:10px; margin-bottom:15px; margin-left:20px; } 推荐使用简写 .margin-test { margin: 5px 10px 15px 20px; } 顺序：上右下左 常见居中 .mycenter { margin: 0 auto; } padding内填充 .padding-test { padding-top: 5px; padding-right: 10px; padding-bottom: 15px; padding-left: 20px; } 推荐使用简写 .padding-test { padding: 5px 10px 15px 20px; } 顺序：上右下左 补充padding的常用简写方式： 提供一个，用于四边； 提供两个，第一个用于上－下，第二个用于左－右； 如果提供三个，第一个用于上，第二个用于左－右，第三个用于下； 提供四个参数值，将按上－右－下－左的顺序作用于四边 body的外边距 边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下， body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了 body{ border: 1px solid; background-color: cadetblue; } 解决方法如下 body{ margin: 0; } margin collapse（边界塌陷或者说边界重叠） 1、兄弟div： 上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值 2、父子div： if 父级div中没有border，padding，inlinecontent，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content中的其中一个，然后按此div 进行margin Title body{ margin: 0px; } .div1{ background-color: rebeccapurple; width: 300px; height: 300px; overflow: hidden; } .div2{ background-color: green; width: 100px; height: 100px; margin-bottom: 40px; margin-top: 20px; } .div3{ background-color:teal; width: 100px; height: 100px; margin-top: 20px; } 解决方法 overflow: hidden; float属性:jack_o_lantern: 在 CSS 中，任何元素都可以浮动。 浮动元素会生成一个块级框，而不论它本身是何种元素。 关于浮动的两个特点： 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 三种取值 left：向左浮动 right：向右浮动 none：默认值，不浮动 基本浮动规则 先了解一下block元素和inline元素在文档流中的排列方式。 　　block元素通常被现实为独立的一块，独占一行，多个block元素会各自新起一行，默认block元素宽度自动填满其父元素宽度。block元素可以设置width、height、margin、padding属性； 　　inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width、height属性无效 常见的块级元素有 div、form、table、p、pre、h1～h5、dl、ol、ul 等。 常见的内联元素有span、a、strong、em、label、input、select、textarea、img、br等 所谓的文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。 脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。 ​ 假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。此外，浮动的框之后的block元素元素会认为这个框不存在，但其中的文本依然会为这个元素让出位置。 浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列。 Title *{ margin: 0; } .r1{ width: 300px; height: 100px; background-color: #7A77C8; float: left; } .r2{ width: 200px; height: 200px; background-color: wheat; /*float: left;*/ } .r3{ width: 100px; height: 200px; background-color: darkgreen; float: left; } 非完全脱离文档流 左右结构div盒子重叠现象，一般是由于相邻两个DIV一个使用浮动一个没有使用浮动。一个使用浮动一个没有导致DIV不是在同个“平面”上，但内容不会造成覆盖现象，只有DIV形成覆盖现象。 Title *{ margin: 0; } .r1{ width: 100px; height: 100px; background-color: #7A77C8; float: left; } .r2{ width: 200px; height: 200px; background-color: wheat; } region2 解决方法：要么都不使用浮动；要么都使用float浮动；要么对没有使用float浮动的DIV设置margin样式。 父级坍塌现象 Title * { margin:0;padding:0; } .container{ border:1px solid red;width:300px; } #box1{ background-color:green;float:left;width:100px;height:100px; } #box2{ background-color:deeppink; float:right;width:100px;height:100px; } #box3{ background-color:pink;height:40px; } box1 向左浮动 box2 向右浮动 box3 如上：.container和box3的布局是上下结构，上图发现box3跑到了上面，与.container产生了重叠，但文本内容没有发生覆盖，只有div发生覆盖现象。这个原因是因为第一个大盒子里的子元素使用了浮动，脱离了文档流，导致.container没有被撑开。box3认为.container没有高度（未被撑开），因此跑上去了。 解决方法： 1、固定高度 给.container设置固定高度，一般情况下文字内容不确定多少就不能设置固定高度，所以一般不能设置“.container”高度(当然能确定内容多高，这种情况下“.container是可以设置一个高度即可解决覆盖问题。 或者给.container加一个固定高度的子div box1 向左浮动 box2 向右浮动 box3 但是这样限定固定高度会使页面操作不灵活，不推荐！ 2、清除浮动(推荐) clear属性规定元素的哪一侧不允许其他浮动元素。 值 描述 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 none 默认值。允许浮动元素出现在两侧。 inherit 规定应该从父元素继承 clear 属性的值 但是需要注意的是：clear属性只会对自身起作用，而不会影响其他元素。 Title *{ margin: 0; } .r1{ width: 300px; height: 100px; background-color: #7A77C8; float: left; } .r2{ width: 200px; height: 200px; background-color: wheat; float: left; clear: left; } .r3{ width: 100px; height: 200px; background-color: darkgreen; float: left; } 把握住两点：1、元素是从上到下、从左到右依次加载的。 ​ 2、clear: left;对自身起作用，一旦左边有浮动元素，即切换到下一行来保证左边元素不是浮动的，依据这一点解决父级塌陷问题。 解决父级塌陷 .clearfix:after { 简写 .clearfix:after { content: \"\"; display: block; clear: both; } 3、overflow:hidden overflow：hidden的含义是超出的部分要裁切隐藏，float的元素虽然不在普通流中，但是他是浮动在普通流之上的，可以把普通流元素+浮动元素想象成一个立方体。如果没有明确设定包含容器高度的情况下，它要计算内容的全部高度才能确定在什么位置hidden，这样浮动元素的高度就要被计算进去。这样包含容器就会被撑开，清除浮动。 overflow溢出属性:jack_o_lantern: 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 overflow（水平和垂直均设置） overflow-x（设置水平方向） overflow-y（设置垂直方向） position(定位):jack_o_lantern: static static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。 relative（相对定位） 定义：相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。 注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。 absolute（绝对定位） 定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。 另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。 fixed（固定） fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。 ​ 在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。 #返回顶部 Title *{ margin: 0; } .back{ background-color: wheat; width: 100%; height: 1200px; } span{ display: inline-block; width: 80px; height: 50px; position: fixed; bottom: 20px; right: 20px; background-color: rebeccapurple; color: white; text-align: center; line-height: 50px; } 返回顶部 z-index:jack_o_lantern: #i2 { z-index: 999; } 设置对象的层叠顺序，数值大的会覆盖在数值小的标签之上。z-index 仅能在定位元素上奏效。 #自定义模态框 自定义模态框 .cover { background-color: rgba(0,0,0,0.65); position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 998; } .modal { background-color: white; position: fixed; width: 600px; height: 400px; left: 50%; top: 50%; margin: -200px 0 0 -300px; z-index: 1000; } opacity:jack_o_lantern: 用来定义透明效果。取值范围是0~1，0是完全透明，1是完全不透明。 Other:jack_o_lantern: 默认的高度和宽度问题 父子都是块级元素 fortest div.parent{ width: 500px; height: 300px; background: #ccc; } div.son{ width: 100%; height: 200px; background: green; } 这时，子元素设置为了父元素width的100%，那么子元素的宽度也是500px；但是如果我们把子元素的width去掉之后，就会发现子元素还是等于父元素的width。也就是说，对于块级元素，子元素的宽度默认为父元素的100%。 当我们给子元素添加padding和margin时，可以发现宽度width是父元素的宽度减去子元素的margin值和padding值。 毫无疑问，如果去掉子元素的height，就会发先子元素的高度为0，故height是不会为100%的，一般我们都是通过添加内容（子元素）将父元素撑起来。 父：块级元素 子：内联元素 如果内联元素是不可替换元素（除img，input以外的一般元素），元素是没有办法设置宽度的，也就谈不上100%的问题了。 即内联元素必须依靠其内部的内容才能撑开。 如果内联元素是可替换元素（img，input，本身可以设置长和宽），不管怎么设置父元素的宽度和高度，而不设置img的宽和高时，img总是表现为其原始的宽和高。 ... div.parent{ width: 500px; height: 300px; background: #ccc; } img{ height: 100px; background: green; } 由此我们可以发现，虽然没有设置宽度，但是表现在浏览器上为160px，它并没有继承父元素的100%得到500px，而是根据既定的高度来等比例缩小宽度。 同样， 如果只设置width，那么height也会等比例改变。 如果我们把img的width设置为100%，就可以发现其宽度这时就和父元素的宽度一致了。而我们一般的做法时，首先确定img的父元素的宽度和高度，然后再将img的宽度和高度设置位100%，这样，图片就能铺满父元素了。 "},"Web/03-JavaScript.html":{"url":"Web/03-JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript概述 JavaScript历史 JavaScript 是脚本语言。 JavaScript 是一种轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 JavaScript 很容易学习。 1992年Nombas开发出C-minus-minus(C--)的嵌入式脚本语言(最初绑定在CEnvi软件中).后将其改名ScriptEase.(客户端执行的语言) Netscape(网景)接收Nombas的理念,(Brendan Eich)在其Netscape Navigator 2.0产品中开发出一套livescript的脚本语言.Sun和Netscape共同完成.后改名叫Javascript 微软随后模仿在其IE3.0的产品中搭载了一个JavaScript的克隆版叫Jscript. 为了统一三家,ECMA(欧洲计算机制造协会)定义了ECMA-262规范.国际标准化组织及国际电工委员会（ISO/IEC）也采纳 ECMAScript 作为标准（ISO/IEC-16262）。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。EcmaScript是规范. ECMAScript 年份 名称 描述 1997 ECMAScript 1 第一个版本 1998 ECMAScript 2 版本变更 1999 ECMAScript 3 添加正则表达式添加try/catch ECMAScript 4 没有发布 2009 ECMAScript 5 添加\"strict mode\"严格模式添加JSON支持 2011 ECMAScript 5.1 版本变更 2015 ECMAScript 6 添加类和模块 2016 ECMAScript 7 增加指数运算符（**）增加Array.prototype.includes 注：ES6就是指ECMAScript 6。 尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的： 核心（ECMAScript） 文档对象模型（DOM） Document object model (整合js，css，html) 浏览器对象模型（BOM） Broswer object model（整合js和浏览器） Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的. 简单地说，ECMAScript 描述了JavaScript语言本身的相关内容 语法 类型 语句 关键字 保留字 运算符 对象 (封装 继承 多态) 基于对象的语言.使用对象. JavaScript基础 引入方式 Script标签内写代码 // 在这里写你的JS代码 引入额外的JS文件 语言规范 注释 // 单行注释 /*多行注释*/ 结束符 JavaScript中的语句要以分号（;）为结束符。 输出 alert() ​ 有阻塞作用，不点击确定，后续代码无法继续执行 ​ alert()只能输出string,如果alert输出的是对象会自动调用toString()方法 ​ alert不支持多个参数的写法,只能输出第一个值 alert([1,2,3]); //'1,2,3' alert(1,2,3); //1 console.log() ​ 在打印台输出 ​ 可以打印任何类型的数据 ​ 支持多个参数的写法 console.log([1,2,3]); //[1,2,3] console.log(1,2,3); // 1 2 3 变量 1、JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。 2、声明变量使用 var 变量名; 的格式来进行声明 var name = \"Timo\"; var age = 3; 3、一行可以声明多个变量.并且可以是不同类型 var name=\"Timo\", age=3, job=\"ad\"; 4、声明变量时 可以不用var. 如果不用var 那么它是全局变量 注意： ​ 变量名是区分大小写的。 ​ 推荐使用驼峰式命名规则。 ​ 保留字不能用做变量名。 #保留字 abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 常量 常量 ：直接在程序中出现的数据值 标识符： ​ 1.由不以数字开头的字母、数字、下划线(_)、美元符号($)组成 ​ 2.常用于表示函数、变量等的名称 ​ 3.例如：_abc,$abc,abc,abc123是标识符，而1abc不是 ​ 4.JavaScript语言中代表特定含义的词称为保留字，不允许程序再定义为标识符 数据类型 JavaScript拥有动态类型 var x; // 此时x是undefined var x = 3; // 此时x是数字 var x = \"timo\"; // 此时x是字符串 数字类型(Number) 不区分整型数值和浮点型数值; 所有数字都采用64位浮点格式存储，相当于Java和C语言中的double格式 能表示的最大值是±1.7976931348623157 x 10308 能表示的最小值是±5 x 10 -324 　 整数： ​ 在JavaScript中10进制的整数由数字的序列组成 ​ 精确表达的范围是-9007199254740992 (-253) 到 9007199254740992 (253) ​ 超出范围的整数，精确度将受影响 浮点数： ​ 使用小数点记录数据 ​ 例如：3.4，5.6 ​ 使用指数记录数据 ​ 例如：4.3e23 = 4.3 x 1023 16进制和8进制数的表达: ​ 16进制数据前面加上0x，八进制前面加0;16进制数是由0-9,A-F等16个字符组成;8进制数由0-7等8个数字组成 ​ 16进制和8进制与2进制的换算: 2进制: 1111 0011 1101 0100 16进制:0xF3D4 10进制:62420 2进制: 1 111 001 111 010 100 8进制:0171724 还有一种NaN，表示不是一个数字（Not a Number）。 parseInt(\"123\") // 返回123 parseInt(\"ABC\") // 返回NaN,NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。 parseFloat(\"123.456\") // 返回123.456 字符串类型(String) 由Unicode字符、数字、标点符号组成的序列；字符串常量首尾由单引号或双引号括起；JavaScript中没有字符类型；常用特殊字符在字符串中的表达； 字符串中部分特殊字符必须加上右划线\\；常用的转义字符 \\n:换行 \\':单引号 \\\":双引号 \\:右划线 var a = \"Hello\" var b = \"world; var c = a + b; console.log(c); // 得到Helloworld 字符串创建(两种方式) ​ 1、变量 = “字符串” ​ 2、字串对象名称 = new String (字符串) var str1=\"hello world\"; var str1= new String(\"hello world\"); 常用方法 方法 说明 .length 获取字符串的长度 .trim() 去除字符串两边空格 .trimLeft() 移除字符串左边的空白 .trimRight() 移除字符串右边的空白 .charAt(index) 获取指定位置字符，其中index为要获取的字符索引 .concat(value, ...) 拼接 .indexOf(findstr,start) .lastIndexOf(findstr) 子序列位置 .slice(start, end) 切片操作字符串 .toLowerCase() 转为小写 .toUpperCase() 转为大写 .split(delimiter, limit) 分割字符串 .match(regexp) 返回匹配字符串的数组，如果没有匹配则返回null .search(regexp) 返回匹配字符串的首字符位置索引 .substring(start,length) .substring(start, end) start表示开始位置，length表示截取长度，end是结束位置 .replace(findstr,tostr) 字符串替换 拼接字符串一般使用“+” string.slice(start, stop)和string.substring(start, stop)区别 两者的相同点： 如果start等于end，返回空字符串 如果stop参数省略，则取到字符串末 如果某个参数超过string的长度，这个参数会被替换为string的长度 substirng()的特点： 如果 start > stop ，start和stop将被交换 如果参数是负数或者不是数字，将会被0替换 silce()的特点： 如果 start > stop 不会交换两者 如果start小于0，则切割从字符串末尾往前数的第abs(start)个的字符开始(包括该位置的字符) 如果stop小于0，则切割在从字符串末尾往前数的第abs(stop)个字符结束(不包含该位置字符) 布尔类型(Boolean) Boolean类型仅有两个值：true和false，也代表1和0，实际运算中true=1,false=0。 区别于Python，true和false都是小写。布尔值也可以看作on/off、yes/no、1/0对应true/false。 var a = true; var b = false; Boolean值主要用于JavaScript的控制语句。 if (x==1){ y=y+1; }else{ y=y-1; } Null和Undefined类型 Undefined类型 Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。 当函数无明确返回值时，返回的也是值 \"undefined\"; Null类型 另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。 尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。 数组(Array) 类似于Python中的列表。 创建数组的三种方式 创建方式1: var arrname = [元素0,元素1,…]; // var arr=[1,2,3]; 创建方式2: var arrname = new Array(元素0,元素1,….); // var test=new Array(100,\"a\",true); 创建方式3: var arrname = new Array(长度); // 初始化数组对象: var cnweek=new Array(7); cnweek[0]=\"星期日\"; cnweek[1]=\"星期一\"; ... cnweek[6]=\"星期六\"; 常用方法 方法 说明 .length 数组的大小 .push(ele) 尾部追加元素 .pop() 获取尾部的元素 .unshift(ele) 头部插入元素 .shift() 头部移除元素 .slice(start, end) 切片 .reverse() 反转 .join(seq) 将数组元素连接成字符串 .concat(val, ...) 连接数组 .sort() 排序 关于sort 如果调用sort方法时没有传入参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 */ // 根据上面的规则自行实现一个排序函数： function sortNumber(a,b) { return a - b } // 调用sort方法时将定义好的排序函数传入即可。 stringObj.sort(sortNumber) 二维数组 var cnweek=new Array(7); for (var i=0;i可以使用for循环遍历数组中的元素 var a = [10, 20, 30, 40]; for (var i=0;i#js中数组的特性 //java中数组的特性, 规定是什么类型的数组,就只能装什么类型.只有一种类型. //js中的数组特性1: js中的数组可以装任意类型,没有任何限制. //js中的数组特性2: js中的数组,长度是随着下标变化的.用到多长就有多长. var arr5 = ['abc',123,1.14,true,null,undefined,new String('1213'),new Function('a','b','alert(a+b)')]; /* alert(arr5.length);//8 arr5[10] = \"hahaha\"; alert(arr5.length); //11 alert(arr5[9]);// undefined */ 运算符 算术运算符： + - * / % ++ -- 比较运算符： > >= 算术运算符 自加自减 假如x=2，那么x++表达式执行后的值为3，x--表达式执行后的值为1；i++相当于i=i+1，i--相当于i=i-1； 递增和递减运算符可以放在变量前也可以放在变量后：--i var i=10; console.log(i++); console.log(i); console.log(++i); console.log(i); console.log(i--); console.log(--i); 单元运算符 - 除了可以表示减号还可以表示负号 例如：x=-y + 除了可以表示加法运算还可以用于字符串的连接 例如：\"abc\"+\"def\"=\"abcdef\" JS不同于Python，是一门弱类型语言 #静态类型语言 一种在编译期间就确定数据类型的语言。大多数静态类型语言是通过要求在使用任一变量之前声明其数据类型来保证这一点的。Java 和 C 是静态类型语言。 动态类型语言 一种在运行期间才去确定数据类型的语言，与静态类型相反。VBScript 和 Python 是动态类型的，因为它们确定一个变量的类型是在您第一次给它赋值的时候。 #强类型语言 一种总是强制类型定义的语言。Java 和 Python 是强制类型定义的。您有一个整数，如果不明确地进行转换 ，不能将把它当成一个字符串去应用。 #弱类型语言 一种类型可以被忽略的语言，与强类型相反。JS 是弱类型的。在JS中，可以将字符串 '12' 和整数 3 进行连接得到字符串'123'，然后可以把它看成整数 123 ，所有这些都不需要任何的显示转换。 所以说 Python 既是动态类型语言 (因为它不使用显示数据类型声明)，又是强类型语言 (因为只要一个变量获得了一个数据类型，它实际上就一直是这个类型了)。 NaN var d=\"timo\"; d=+d; alert(d);//NaN:属于Number类型的一个特殊值,当遇到将字符串转成数字无效时,就会得到一个NaN数据 alert(typeof(d));//Number //NaN特点: var n=NaN; alert(n>3); alert(n比较运算符 用于控制语句时 if (2>1){ console.log(\"Hello World!\") } 等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 console.log(2==2); console.log(2==\"2\"); console.log(2===\"2\"); console.log(2!==\"2\"); #Attention var bResult = \"Blue\" #Attention 等性运算符：执行类型转换的规则如下： 如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 在比较时，该运算符还遵守下列规则： 值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 逻辑运算符 if (2>1 && [1,2]){ console.log(\"条件与\") } // 思考返回内容 console.log(1 && 3); //与 console.log(0 && 3); console.log(0 || 3); //或 console.log(2 || 3); 三元运算 var a = 1; var b = 2; var c = a > b ? a : b 流程控制 顺序结构(从上向下顺序执行) 分支结构 循环结构 顺序结构 console.log(“星期一”); console.log(“星期二”); console.log(“星期三”); 分支结构 if-else结构 if (表达式){ 语句１; ...... } else{ 语句２; ..... } 功能说明：如果表达式的值为true则执行语句1,否则执行语句2 var x= (new Date()).getDay(); //获取今天的星期值，0为星期天 var y; if ( (x==6) || (x==0) ) { y=\"周末\"; }else{ y=\"工作日\"; } console.log(y); /*等价于 y=\"工作日\"; if ( (x==6) || (x==0) ) { y=\"周末\"; } console.log(y); */ if-elif-else结构 if (表达式1) { 语句1; }else if (表达式2){ 语句2; }else if (表达式3){ 语句3; } else{ 语句4; } var score=window.prompt(\"您的分数:\"); if (score>90){ ret=\"优秀\"; }else if (score>80){ ret=\"良\"; }else if (score>60){ ret=\"及格\"; }else { ret = \"不及格\"; } alert(ret); switch-case结构 switch (表达式) { case 值1:语句1;break; case 值2:语句2;break; case 值3:语句3;break; default:语句4; } switch比else if结构更加简洁清晰，使程序可读性更强，效率更高。 switch(x){ case 1:y=\"星期一\"; break; case 2:y=\"星期二\"; break; case 3:y=\"星期三\"; break; case 4:y=\"星期四\"; break; case 5:y=\"星期五\"; break; case 6:y=\"星期六\"; break; case 7:y=\"星期日\"; break; default: y=\"未定义\"; //如果前面都不执行就执行default } switch中的case子句通常都会加break语句，否则程序会继续执行后续case中的语句。 循环结构 for循环 语法规则： for(初始表达式;条件表达式;自增或自减) { 执行语句 ... } 功能说明：实现条件循环，当条件成立时，执行语句，否则跳出循环体 for (var i=0;ifor循环的另一种形式 for( 变量 in 数组或对象) { 执行语句 ... } while循环 语法规则： while (条件){ 语句1； ... } 功能说明：运行功能和for类似，当条件成立循环执行语句花括号{}内的语句，否则跳出循环；同样支持continue与break语句。 var i = 0; while (i 异常处理 try { //这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行 } catch (e) { // 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。 //e是一个局部变量，用来指向Error对象或者其他抛出的对象 } finally { //无论try中代码是否有异常抛出（甚至是try代码块中有return语句），finally代码块中始终会被执行。 } 主动抛出异常 throw Error('...') 函数 函数的定义 JavaScript中的函数和Python中的非常类似，只是定义方式有点区别。 function 函数名 (参数){ 函数体; return 返回值; } 功能说明： 可以使用变量、常量或表达式作为函数调用的参数 函数由关键字function定义 函数名的定义规则与标识符一致，大小写是敏感的 返回值必须使用return Function 类可以表示开发者定义的任何函数。 用 Function 类直接创建函数的语法 var 函数名 = new Function(\"参数1\",\"参数n\",\"function_body\"); 虽然由于字符串的关系，第二种形式写起来有些困难，但有助于理解函数只不过是一种引用类型，它们的行为与用 Function 类明确创建的函数行为是相同的。 function func1(name){ alert('hello'+name); return 8 } ret=func1(\"timo\"); alert(ret); var func2=new Function(\"name\",\"alert(\\\"hello\\\"+name);\") func2(\"ali\") JS的函数加载执行与Python不同，它是整体加载完才会执行，所以执行函数放在函数声明上面或下面都可以 f(); // --->OK function f(){ console.log(\"hello\") } f(); //----->OK // 普通函数定义 function f1() { console.log(\"Hello world!\"); } // 带参数的函数定义 function f2(a, b) { console.log(arguments); // 内置的arguments对象 console.log(arguments.length); console.log(a, b); } // 带返回值的函数定义 function sum(a, b){ return a + b; } // 立即执行函数 (function(a, b){ return a + b; })(1, 2); 属性 函数属于引用类型，所以它们也有属性和方法。 ECMAScript 定义的属性 length 声明了函数期望的参数个数。 console.log(func1.length) 调用 function func1(a,b){ console.log(a+b); } func1(1,2); //3 func1(1,2,3); //3 func1(1); //NaN func1(); //NaN //只要函数名写对即可,参数怎么填都不报错. #扩展 function a(a,b){ alert(a+b); } var a=1; var b=2; a(a,b) 内置arguments function add(a,b){ console.log(a+b);//3 console.log(arguments.length);//2 console.log(arguments);//[1,2] } add(1,2) #arguments的用处1 function nxAdd(){ var result=0; for (var num in arguments){ result+=arguments[num] } console.log(result) } nxAdd(1,2,3,4,5) #arguments的用处2 function f(a,b,c){ if (arguments.length!=3){ throw new Error(\"function f called with \"+arguments.length+\" arguments,but it just need 3 arguments\") } else { alert(\"success!\") } } f(1,2,3,4,5) 匿名函数 // 匿名函数 var func = function(arg){ return \"tony\"; } // 匿名函数的应用 (function(){ alert(\"tony\"); } )() (function(arg){ console.log(arg); })('123') 全局变量和局部变量 局部变量： 在JavaScript函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。只要函数运行完毕，本地变量就会被删除。 全局变量： 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 变量生存周期： JavaScript变量的生命期从它们被声明的时间开始。 局部变量会在函数运行以后被删除。 全局变量会在页面关闭后被删除。 作用域 首先在函数内部查找变量，找不到则到外层函数查找，逐步找到最外层。 var city = \"BeiJing\"; function f() { var city = \"ShangHai\"; function inner(){ var city = \"ShenZhen\"; console.log(city); } inner(); } f(); //输出结果是？ var city = \"BeiJing\"; function Bar() { console.log(city); } function f() { var city = \"ShangHai\"; return Bar; } var ret = f(); ret(); // 打印结果是？ 闭包 var city = \"BeiJing\"; function f(){ var city = \"ShangHai\"; function inner(){ console.log(city); } return inner; } var ret = f(); ret(); 词法分析 JavaScript中在调用函数的那一瞬间，会先进行词法分析。 词法分析的过程： 当函数调用的前一瞬间，会先形成一个激活对象：Avtive Object（AO），并会分析以下3个方面： 1:函数参数，如果有，则将此参数赋值给AO，且值为undefined。如果没有，则不做任何操作。 2:函数局部变量，如果AO上有同名的值，则不做任何操作。如果没有，则将此变量赋值给AO，并且值为undefined。 3:函数声明，如果AO上有，则会将AO上的对象覆盖。如果没有，则不做任何操作。 函数内部无论是使用参数还是使用局部变量都到AO上找。 var age = 18; function foo(){ console.log(age); var age = 22; console.log(age); } foo(); // 问：执行foo()之后的结果是？ var age = 18; function foo(){ console.log(age); var age = 22; console.log(age); function age(){ console.log(\"呵呵\"); } console.log(age); } foo(); // 执行后的结果是？ 词法分析过程： 1、分析参数，有一个参数，形成一个 AO.age=undefine; 2、分析变量声明，有一个 var age, 发现 AO 上面已经有一个 AO.age，因此不做任何处理 3、分析函数声明，有一个 function age(){...} 声明， 则把原有的 age 覆盖成 AO.age=function(){...}; 最终，AO上的属性只有一个age，并且值为一个函数声明 执行过程： 注意：执行过程中所有的值都是从AO对象上去寻找 1、执行第一个 console.log(age) 时，此时的 AO.age 是一个函数，所以第一个输出的一个函数 2、这句 var age=22; 是对 AO.age 的属性赋值， 此时AO.age=22 ，所以在第二个输出的是 2 3、同理第三个输出的还是22, 因为中间再没有改变age值的语句了 对象和方法 在JavaScript中除了null和undefined以外其他的数据类型都被定义成了对象，也可以用创建对象的方法定义变量，String、Number、Math、Array、Date、RegExp都是JavaScript中重要的内置对象，在JavaScript程序大多数功能都是基于对象实现的。在JavaScript中，对象是拥有属性和方法的数据。 var aa=Number.MAX_VALUE; //利用数字对象获取可表示最大数 var bb=new String(\"hello JavaScript\"); //创建字符串对象 var cc=new Date(); //创建日期对象 var dd=new Array(\"星期一\",\"星期二\",\"星期三\",\"星期四\"); //数组对象 注意var s1 = \"abc\"和var s2 = new String(\"abc\")的区别：typeof s1 --> string而 typeof s2 --> Object 类型 内置对象 介绍 数据对象 Number 数字对象 String 字符串对象 Boolean 布尔值对象 组和对象 Array 数组对象 Math 数学对象 Date 日期对象 高级对象 Object 自定义对象 Error 错误对象 Function 函数对象 RegExp 正则表达式对象 Global 全局对象 "},"Web/04-BOM And DOM.html":{"url":"Web/04-BOM And DOM.html","title":"BOM And DOM","keywords":"","body":"BOM对象 BOM（Browser Object Model）是指浏览器对象模型，它使 JavaScript 有能力与浏览器进行“对话”。 window对象 window对象是客户端JavaScript最高层对象之一，由于window对象是其它大部分对象的共同祖先在调用window对象的方法和属性时，可以省略window对象的引用。如：window.document.write()可以简写成document.write() 所有JavaScript全局对象、函数以及变量均自动成为window对象的成员，全局变量是window对象的属性，全局函数是window对象的方法。 没有应用于window对象的标准，但所有浏览器都支持window对象。 概念上讲：一个html文档对应一个window对象 功能上讲：控制浏览器窗口的 使用上讲：window对象不需要创建对象，直接使用即可 常用的Window方法： window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 window.open() - 打开新窗口 window.close() - 关闭当前窗口 window对象方法 navigator对象 浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息 navigator.appName　　// Web浏览器全称 navigator.appVersion　　// Web浏览器厂商和版本的详细字符串 navigator.userAgent　　// 客户端绝大部分信息 navigator.platform　　　// 浏览器运行所在的操作系统 screen对象 屏幕对象，不常用。 一些属性： screen.availWidth - 可用的屏幕宽度 screen.availHeight - 可用的屏幕高度 history对象 浏览历史对象，包含了用户当前页面的浏览历史，但我们无法查看具体的地址，可以简单的用来前进或后退一个页面 history.forward() // 前进一页 history.back() // 后退一页 location对象 用于获得当前页面的URL，并把浏览器重定向到新的页面 常用属性和方法 location.href 获取URL location.href=\"URL\" // 跳转到指定页面 location.reload() 重新加载页面 window常用方法 alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 prompt() 显示可提示用户输入的对话框。 open() 打开一个新的浏览器窗口或查找一个已命名的窗口。 close() 关闭浏览器窗口。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 scrollTo() 把内容滚动到指定的坐标。 弹出框 可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框。 警告框经常用于确保用户可以得到某些信息。 当警告框出现后，用户需要点击确定按钮才能继续进行操作。 alert(\"你看到了吗？\"); 确认框用于使用户可以验证或者接受某些信息。 当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。 如果用户点击确认，那么返回值为 true。如果用户点击取消，那么返回值为 false。 confirm(\"你确定吗？\") 提示框经常用于提示用户在进入页面前输入某个值。 当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。 如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。 prompt(\"请在下方输入\",\"你的答案\") 计时相关 通过使用 JavaScript，我们可以在一定时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。 setTimeout() #语法 var t=setTimeout(\"JS语句\",毫秒) setTimeout() 方法会返回某个值。在上面的语句中，值被储存在名为 t 的变量中。假如你希望取消这个 setTimeout()，你可以使用这个变量名来指定它。 setTimeout() 的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 \"alert('5 seconds!')\"，或者对函数的调用，诸如 alertMsg()\"。 第二个参数指示从当前起多少毫秒后执行第一个参数（1000 毫秒等于一秒）。 clearTimeout() #语法 clearTimeout(setTimeout_variable) // 在指定时间之后执行一次相应函数 var timer = setTimeout(function(){alert(123);}, 3000) // 取消setTimeout设置 clearTimeout(timer); setInterval() setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 #语法 setInterval(\"JS语句\",时间间隔) 返回值 一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。 clearInterval() clearInterval() 方法可取消由 setInterval() 设置的 timeout。 clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。 #语法 clearInterval(setinterval返回的ID值) / 每隔一段时间就执行一次相应函数 var timer = setInterval(function(){console.log(123);}, 3000) // 取消setInterval设置 clearInterval(timer); #定时器 定时器 var intervalId; function f() { var timeStr = (new Date()).toLocaleString(); var inputEle = document.getElementById(\"i1\"); inputEle.value = timeStr; } function start() { f(); if (intervalId === undefined) { intervalId = setInterval(f, 1000); } } function end() { clearInterval(intervalId); intervalId = undefined; } DOM对象 DOM（Document Object Model）是一套对文档的内容进行抽象和概念化的方法。 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 定义了访问和操作HTML文档的标准方法。 HTML DOM 把 HTML 文档呈现为带有元素、属性和文本的树结构（节点树)。 DOM树是为了展示文档中各个对象之间的关系，用于对象的导航。 DOM节点 节点类型 DOM标准规定HTML文档中的每个成分都是一个节点(node)： 文档节点(document对象)：代表整个文档 元素节点(element 对象)：代表一个元素（标签） 文本节点(text对象)：代表元素（标签）中的文本 属性节点(attribute对象)：代表一个属性，元素（标签）才有属性 注释是注释节点(comment对象)　 JavaScript 可以通过DOM创建动态的 HTML： JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 其中，document与element节点是重点。 节点关系 "}}