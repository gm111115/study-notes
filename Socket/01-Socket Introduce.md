# Socket

### 操作系统基础:jack_o_lantern:

操作系统(Operating System , 简称OS)：是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在计算机上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行

操作系统是用户和计算机的接口，同时也是计算机硬件和其它软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，改善人机界面，为其它应用软件提供支持，让计算机系统所有资源最大限度地发挥作用，提供各种形式的用户界面，使用户有一个好的工作环境，为其它软件的开发提供必要的服务和相应的接口等。实际上，用户是不用接触操作系统的，操作系统管理着计算机硬件资源，同时按照应用程序的资源请求，分配资源，如：划分CPU时间，内存空间的开辟等

ps：计算机(硬件) - OS - 应用软件

### 网络通信原理:jack_o_lantern:

#### 互联网的本质就是一系列的网络协议

#### OSI七层协议

##### 基本介绍

​	ISO国际标准组织所定义的开放系统互连七层模型的定义和各层功能。它是网络技术入门者的敲门砖，也是分析、评判各种网络技术的依据—从此网络不再神秘，它也是有理可依，有据可循的。

　　建立七层模型主要是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来；也使网络的不同功能模块分担起不同的职责。

　　网络发展中一个重要里程碑便是ISO（Internet Standard Organization，国际标准组织对OSI(Open System Interconnect)，开放系统互连）七层网络模型的定义。它不但成为以前的和后续的各种网络技术评判、分析的依据，也成为网络协议设计和统一的参考模型。

　　建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。网络七层的划分也是为了使网络的不同功能模块（不同层次）分担起不同的职责，从而带来如下好处：

　　● 减轻问题的复杂程度，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错

　　● 在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则相对独立，一种高层协议可放在多种低层协议上运行

　　● 能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手术

　　● 便于研究和教学

##### OSI各层介绍

​	**OSI 七层模型**称为开放式系统互联参考模型 OSI 七层模型是一种框架性的设计方法

　　OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能使就是帮助不同类型的主机实现数据传输

[![osi七层模型](http://pic.baike.soso.com/p/20130702/20130702225815-125412048.jpg)](http://baike.sogou.com/PicBooklet.v?relateImageGroupIds=&lemmaId=7567773&now=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20130702%2F20130702225815-125412048.jpg&type=1)							    　                                                  osi七层模型　

​	**物理层** ：OSI模型的最低层或第一层，该层包括物理连网媒介，如电缆连线连接器。物理层的协议产生并检测电压以便发送和接收携带数据的信号。在你的桌面PC上插入网络接口卡，你就建立了计算机连网的基础。换言之，你提供了一个物理层。尽管物理层不提供纠错服务，但它能够设[数据传输速率并监测数据出错率。网络物理问题，如电线断开，将影响物理层。

　　用户要传递信息就要利用一些物理媒体，如双绞线、同轴电缆等，但具体的物理媒体并不在OSI的7层之内，有人把物理媒体当做第0层，物理层的任务就是为它的上一层提供一个物理连接，以及它们的机械、电气、功能和过程特性。如规定使用电缆和接头的类型、传送信号的电压等。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理，单位是比特。

　　**数据链路层**：OSI模型的第二层，它控制网络层与物理层之间的通信。它的主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的网络地址以及纠错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。 如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。

　　数据链路层的功能独立于网络和它的节点和所采用的物理层类型，它也不关心是否正在运行 Word 、Excel 或使用Internet 。有一些连接设备，如交换机，由于它们要对帧解码并使用帧信息将数据发送到正确的接收方，所以它们是工作在数据链路层的。

　　**网络层**： OSI模型的第三层，其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。

　　网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点Ａ 到另一个网络中节点Ｂ 的最佳路径。由于网络层处理路由，而路由器因为即连接网络各段，并智能指导数据传送，属于网络层。在网络中，“路由”是基于编址方案、使用模式以及可达性来指引数据的发送。

　　**传输层**：OSI模型中最重要的一层。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1500字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。

　　工作在传输层的一种服务是 TCP/IP协议套中的TCP（传输控制协议），另一项传输层服务是IPX /SPX协议集的SPX（序列包交换）。

　　**会话层**： 负责在网络中的两节点之间建立和维持通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对 话，决定通信是否被中断以及通信中断时决定从何处重新发送。

　　你可能常常听到有人把会话层称作网络通信的“交通警察”。当通过拨号向你的 ISP（因特网服务提供商）请求连接到因特网时ISP服务器上的会话层向你与你的PC客户机上的会话层进行协商连接。若你的电话线偶然从墙上插孔脱落时，你终端机上的会话层将检测到连接中断并重新发起连接。会话层通过决定节点通信的优先级和通信时间的长短来设置通信期限

　　**表示层**： 应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。

　　表示层管理数据的解密与加密，如系统口令的处理。例如：在 Internet上查询你银行账户，使用的即是一种安全连接。你的账户数据在发送前被加密，在网络的另一端，表示层将对接收到的数据解密。除此之外，表示层协议还对图片和文件格式信息进行解码和编码。

　　**应用层**： 负责对软件提供接口以使程序能使用网络服务。术语“应用层”并不是指运行在网络上的某个特别应用程序 ，应用层提供的服务包括文件传输、文件管理以及电子邮件的信息处理。

### socket简介:jack_o_lantern:

​	Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，我们经常把socket翻译为套接字，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。

​	所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。

### 套接字发展史及分类:jack_o_lantern:

​	套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 

**基于文件类型的套接字家族**

套接字家族的名字：AF_UNIX

unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信

**基于网络类型的套接字家族**

套接字家族的名字：AF_INET

(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)

### 套接字工作流程:jack_o_lantern:

​       一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理

![img](http://images.cnblogs.com/cnblogs_com/goodcandle/socket3.jpg)

```
import socket
socket.socket(socket_family,socket_type,protocal=0)
socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 0
  
获取tcp/ip套接字
tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  
获取udp/ip套接字
udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
 
由于 socket 模块中有太多的属性。我们在这里破例使用了'from module import *'语句。使用 'from socket import *',我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。
例如tcpSock = socket(AF_INET, SOCK_STREAM)
```

**服务端套接字函数**

s.bind()    绑定(主机,端口号)到套接字
s.listen()  开始TCP监听
s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来

**客户端套接字函数**

s.connect()     主动初始化TCP服务器连接
s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常

**公共用途的套接字函数**

s.recv()            接收TCP数据
s.send()            发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)
s.sendall()         发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)
s.recvfrom()        接收UDP数据
s.sendto()          发送UDP数据
s.getpeername()     连接到当前套接字的远端的地址
s.getsockname()     当前套接字的地址
s.getsockopt()      返回指定套接字的参数
s.setsockopt()      设置指定套接字的参数
s.close()           关闭套接字

**面向锁的套接字方法**

s.setblocking()     设置套接字的阻塞与非阻塞模式
s.settimeout()      设置阻塞套接字操作的超时时间
s.gettimeout()      得到阻塞套接字操作的超时时间

**面向文件的套接字的函数**

s.fileno()          套接字的文件描述符
s.makefile()        创建一个与该套接字相关的文件

##### 基于TCP的套接字

**tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端**

TCP是可靠传输

服务端

```
import socket
phone=socket.socket()
phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
phone.bind(('127.0.0.1',8082))
phone.listen(5)
while True:
    conn,addr=phone.accept()
    print(addr)
    while True:
        try:
            data=conn.recv(1024)
            conn.send(data.upper())
        except ConnectionResetError:
            break
    conn.close()

phone.close()
```

客户端

```
import socket
phone = socket.socket()
phone.connect(('127.0.0.1',8080))

while True:
    msg = input('>>:').strip()
    phone.send(msg.encode('utf-8'))
    data = phone.recv(1024)
    print(data.decode('utf-8'))


phone.close()
```

##### 基于UDP的套接字

**udp是无链接的，先启动哪一端都不会报错**

服务端

```
from socket import *
server = socket(AF_INET,SOCK_DGRAM)
server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
server.bind(('127.0.0.1',8080))

while True:
    data,client_addr = server.recvfrom(1024)
    print('client\'s data:',data)
    server.sendto(data.upper(),client_addr)
```

客户端

    from socket import *
    client = socket(AF_INET,SOCK_DGRAM)
    
    while True:
        msg = input('>>:').strip()
        client.sendto(msg.encode('utf-8'),('127.0.0.1',8080))
        data,server_addr = client.recvfrom(1024)
        print(data.decode('utf-8'))
**ps：**

**tcp是可靠传输，udp是不可靠传输**

tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的

而udp发送数据，对端是不会返回确认信息的，因此不可靠

**send(字节流)和recv(1024)及sendall**

recv里指定的1024意思是从缓存里一次拿出1024个字节的数据

send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失