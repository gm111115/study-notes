# MySQL

## 索引 :jack_o_lantern:

### 介绍

索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理，先定位到章，然后定位到该章下的一个小节，然后找到页数，可以帮助用户快速的找到需要的内容.

本质：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍，能够大大提高查询效率

　　索引优点:可以提高查询效率,而且是数据量越大效果越明显.

　　索引缺点:添加数据和删除数据效率低

### 类型

我们可以在创建索引的时候，为其指定索引类型，分两类
​	hash类型的索引：查询单条快，范围查询慢
​	btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）

　　1、HASH :hash就是一种（key=>value）形式的键值对,允许多个key对应相同的value，但不允许一个key对应多个value,为某一列或几列建立hash索引，就会利用这一列或几列的值通过一定的算法计算出一个hash值，对应一行或几行数据.   hash索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率

　	假设创建如下一个表：
　　　　CREATE TABLE testhash (
  　　　　 fname VARCHAR(50) NOT NULL,
   　　　　lname VARCHAR(50) NOT NULL,
   　　　　KEY USING HASH(fname)
　　　　) ENGINE=MEMORY;
　　包含的数据如下：
　　　　![img](http://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql02-02.JPG) 

　　假设索引使用hash函数f( )，如下：

```
f('Arjen') = 2323
f('Baron') = 7437
f('Peter') = 8784
f('Vadim') = 2458
```

　　此时，索引的结构大概如下：

　　　![img](http://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql02-03.JPG)  

Slots是有序的，但是记录不是有序的。当你执行
　　mysql> SELECT lname FROM testhash WHERE fname='Peter';
MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f('Peter') = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。
因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。

​	2、BTREE: 就是一种将索引值按一定的算法，存入一个树形的数据结构中. 如二叉树一样

　　![img](http://images2017.cnblogs.com/blog/1284211/201711/1284211-20171123143758086-565090818.png)

**不同的存储引擎支持的索引类型也不一样**

InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引
MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引
Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引
NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引
Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引

### 分类

​	1.普通索引

​		INDEX：加速查找

​	2.唯一索引

​		UNIQUE:加速查找+约束（不能重复）

​	3.主键索引

​		PRIMARY KEY：加速查找+约束（不为空、不能重复）

​	4.组合/联合索引

​		PRIMARY KEY(id,name):联合主键索引    

​		UNIQUE(id,name):联合唯一索引    

​		INDEX(id,name):联合普通索引

​	5.FULLTEXT:全文索引

　　　　InnoDB引擎对FULLTEXT索引的支持是MySQL5.6新引入的特性，之前只有MyISAM引擎支持FULLTEXT索引，而且只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引.

　　　　FULLTEXT索引是按照分词原理建立索引的。西方文字中，大部分为字母文字，分词可以很方便的按照空格进行分割。但很明显，中文不能按照这种方式进行分词。这里介绍一个Mysql的中文分词插件Mysqlcft，有了它，就可以对中文进行分词，想了解的可以查看Mysqlcft，当然还有其他的分词插件可以使用。

## MySQL索引管理 :jack_o_lantern:

### 创建索引

```
方法一：创建表时
    　　CREATE TABLE 表名 (
                字段名1  数据类型 [完整性约束条件…],
                字段名2  数据类型 [完整性约束条件…],
                [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY
                [索引名]  (字段名[(长度)]  [ASC |DESC]) 
                );


方法二：CREATE在已存在的表上创建索引
	   CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名 
                     ON 表名 (字段名[(长度)]  [ASC |DESC]) ;


方法三：ALTER TABLE在已存在的表上创建索引
	   ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX
                             索引名 (字段名[(长度)]  [ASC |DESC]) ;
```

#### 普通索引

```
CREATE index 索引名 on 表名(添加索引的字段,多个字段以","间隔)
```

#### 唯一索引

```
CREATE UNIQUE index 索引名 on 表名(字段)
```

#### 主键索引

```
alter table 表名 add primary key(字段);
注意:主键索引只能有一个
```

#### 组合/联合索引

联合索引时指对表上的多个列合起来做一个索引。联合索引的创建方法与单个索引的创建方法一样，不同之处在仅在于有多个索引列，如下

```
create index 索引名 on 表名(字段,字段)
```

### 删除索引

```
DROP INDEX 索引名 ON 表名字;
```

## 事务 :jack_o_lantern:

### 什么是事务 

​	事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。 
​	事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。

　　总结:事务就是一组操作,要么全部完成,要么全部失败!

### 事物特性ACID

　　事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。 

　　1 、原子性  (事物内的操作,要么全部成功,要么全部失败)
​	事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做

　　2 、一致性 (事物之前之后,前后数据的一致性)
​	事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态　如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 

　　3 、隔离性(多个事物时,相互不能干扰) 
​	一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

　   4 、持续性(一旦事物提交(commit)之后,是不可回滚的) 
​	持续性也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 

### 实例操作

​	1.开启事物  start transaction

​	2.提交事物   commit

​	3.回滚事物   rollback



